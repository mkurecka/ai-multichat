This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    prd.mdc
    secuirity-rule.mdc
backend/
  assets/
    controllers/
      csrf_protection_controller.js
      hello_controller.js
    styles/
      app.css
    app.js
    bootstrap.js
    controllers.json
  bin/
    console
    phpunit
  config/
    packages/
      asset_mapper.yaml
      cache.yaml
      csrf.yaml
      debug.yaml
      doctrine_migrations.yaml
      doctrine.yaml
      framework.yaml
      knpu_oauth2_client.yaml
      lexik_jwt_authentication.yaml
      mailer.yaml
      messenger.yaml
      monolog.yaml
      nelmio_cors.yaml
      notifier.yaml
      routing.yaml
      security.yaml
      translation.yaml
      twig.yaml
      validator.yaml
      web_profiler.yaml
    routes/
      framework.yaml
      security.yaml
      web_profiler.yaml
    bundles.php
    preload.php
    routes.yaml
    services.yaml
  migrations/
    Version20250325192728.php
    Version20250325193147.php
    Version20250326154313.php
    Version20250326163907.php
    Version20250326165958.php
    Version20250326170154.php
    Version20250327100649.php
    Version20250327102737.php
    Version20250327224028.php
  public/
    index.php
  src/
    Command/
      CacheModelsCommand.php
      GenerateJwtCommand.php
      CheckOpenRouterCostsCommand.php
    Controller/
      GoogleController.php
      HomeController.php
      ChatController.php
      SecurityController.php
    Entity/
      ChatCost.php
      ChatHistory.php
      Organization.php
      Thread.php
      User.php
    Repository/
      OrganizationRepository.php
      UserRepository.php
    Security/
      GoogleAuthenticator.php
      JWTAuthenticator.php
    Service/
      JWTService.php
      ModelService.php
      OpenRouterService.php
    Kernel.php
  templates/
    home/
      index.html.twig
    base.html.twig
  tests/
    bootstrap.php
  .dockerignore
  .env.dev
  .env.test
  .gitignore
  compose.override.yaml
  compose.yaml
  composer.json
  Dockerfile
  Dockerfile.prod
  importmap.php
  php.ini
  phpunit.xml.dist
  symfony.lock
  test-jwt.php
docker/
  nginx/
    backend.conf
frontend/
  src/
    components/
      Callback.tsx
      CostsPage.tsx
      Header.tsx
      ChatHistory.tsx
      ChatInput.tsx
      ChatMessage.tsx
      ChatWindow.tsx
      Login.tsx
      ModelCheckbox.tsx
      ModelSelector.tsx
    data/
      models.ts
    hooks/
      useAuth.ts
    services/
      api.ts
    App.tsx
    index.css
    index.tsx
    types.ts
    vite-env.d.ts
  .dockerignore
  .gitignore
  Dockerfile
  Dockerfile.prod
  eslint.config.js
  index.html
  nginx.conf
  package.json
  postcss.config.js
  README.md
  tailwind.config.js
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
.env.prod.example
.gitignore
docker-compose.prod.yml
docker-compose.yml
docker-deploy.sh
docker-init.sh
README.md

================================================================
Files
================================================================

================
File: .cursor/rules/prd.mdc
================
---
description: 
globs: 
alwaysApply: true
---
# AI MultiChat - Product Requirements Document (PRD)

## 1. Product Overview

AI MultiChat is a web-based platform that enables users to interact with multiple AI language models simultaneously. The application allows users to compare responses from different LLMs (Language Learning Models) side by side, maintain conversation history, and continue conversations in a thread-based interface.

### 1.1 Architecture

The project follows a modern client-server architecture:

**Frontend:**
- Framework: React 18.3+ with TypeScript
- State Management: React Hooks for local state
- Routing: React Router v7
- UI Components: Custom components with Tailwind CSS
- Icons: Lucide React
- HTTP Client: Axios

**Backend:**
- Framework: Symfony 7 (PHP 8.2+)
- Database: Doctrine ORM
- Authentication: JWT-based authentication via Lexik JWT Bundle
- OAuth: Google OAuth integration
- API Integration: OpenRouter API for accessing multiple LLM providers

## 2. User Personas

### 2.1 Primary User: AI Enthusiast
- Wants to compare different LLM responses to the same prompt
- Interested in the nuances between models like Claude, GPT, Llama, etc.
- Maintains conversation context across multiple interactions

### 2.2 Secondary User: Developer/Researcher
- Needs to evaluate model performance for specific use cases
- Requires conversation history for analysis
- Wants consistent threading to evaluate context retention

## 3. Core Features

### 3.1 Multi-Model Chat Interface
- **Description**: Users can select multiple AI models and send a single prompt to all selected models simultaneously
- **Requirements**:
  - Model selection interface with clear model information
  - Support for up to 16 simultaneous models
  - Visual distinction between model responses
  - Response streaming for real-time feedback

### 3.2 Thread-Based Conversations
- **Description**: All interactions maintain conversation context within a thread
- **Requirements**:
  - Creation of a thread ID for each new conversation
  - Consistent thread maintenance when sending to multiple models
  - Ability to reference and search previous messages in a thread
  - Clean UI presentation of conversation flow

### 3.3 Message History
- **Description**: All conversations are saved and can be revisited
- **Requirements**:
  - Sidebar navigation for accessing past conversations
  - Chronological ordering of conversations
  - Preview of conversation content
  - Ability to resume any past conversation

### 3.4 Authentication
- **Description**: Secure user authentication with Google OAuth
- **Requirements**:
  - Google login integration
  - JWT token management with auto-refresh
  - User profile information display
  - Secure session handling

### 3.5 Context Awareness
- **Description**: Models should be aware of the full conversation history
- **Requirements**:
  - Backend support for context inclusion
  - Ability to reference earlier parts of the conversation
  - Context customization (number of previous messages included)
  - Context search functionality

## 4. Technical Requirements

### 4.1 Frontend

#### 4.1.1 Components
- **Model Selector**: Allow users to select models from available providers
- **Chat Window**: Display conversation history and model responses
- **Chat History Sidebar**: Show past conversations with preview
- **Message Input**: Text area with send functionality
- **Context Controller**: Interface for managing conversation context
- **User Profile**: Display user information and logout option

#### 4.1.2 State Management
- Thread IDs must be maintained consistently
- promptId must be generated and used consistently across all models
- Response streaming must update UI in real-time
- Model selection state must be synchronized with backend requests

#### 4.1.3 API Integration
- JWT token management with automatic refresh
- Proper error handling for API failures
- Streaming response handling
- Consistent use of threadId and promptId

### 4.2 Backend

#### 4.2.1 Controllers
- **ChatController**: Handle message sending, thread management, and history
- **SecurityController**: Handle authentication and token refresh
- **ModelController**: Provide model information and management

#### 4.2.2 Services
- **OpenRouterService**: Interface with the OpenRouter API
- **ModelService**: Manage model information and caching
- **JWTService**: Handle token creation and validation
- **ContextService**: Manage conversation context

#### 4.2.3 Entities
- **User**: Store user information
- **Thread**: Maintain conversation threads
- **ChatHistory**: Store individual messages with associations
- **Organization**: Group users and track usage

#### 4.2.4 API Endpoints
- `/api/models`: Get available models
- `/api/models/refresh`: Refresh model cache
- `/api/chat`: Send messages to models
- `/api/chat/history`: Get conversation history
- `/api/chat/thread/{threadId}`: Get specific thread
- `/api/chat/thread`: Create a new thread
- `/api/chat/context/{threadId}`: Get conversation context
- `/api/chat/search`: Search within conversations
- `/api/token/refresh`: Refresh JWT token

## 5. Data Models

### 5.1 Frontend Types
```typescript
// Message object
interface Message {
  role: 'user' | 'assistant';
  content: string | { content: string } | any;
  modelId?: string;
  id?: string;
  threadId?: string | null;
  promptId?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

// Model information
interface Model {
  id: string;
  name: string;
  description?: string;
  provider?: string;
  selected?: boolean;
  pricing?: {
    prompt: number;
    completion: number;
    unit: string;
  };
}

// Chat session
interface ChatSession {
  id: string;
  title: string;
  messages: Message[];
  selectedModels: string[];
  threadId?: string | null;
  parentId?: string;
}
```

### 5.2 Backend Entities
- **Thread**: Contains threadId, title, user, and creation timestamp
- **ChatHistory**: Contains promptId, thread reference, prompt text, response content, modelId, and timestamp
- **User**: Contains user information, Google ID, and organization reference

## 6. Critical Bug Fixes & Optimizations

### 6.1 Thread Creation Issue
- **Current Problem**: Multiple threads are created when using multiple models instead of sharing one thread
- **Fix Required**: 
  - Create a thread first if none exists, then use the same threadId for all model responses
  - Ensure frontend properly tracks and reuses threadId
  - Maintain consistent promptId across all responses to group them correctly

### 6.2 Context Handling
- **Implementation Required**:
  - Create a ContextService to retrieve and format conversation history
  - Add context inclusion option to frontend UI
  - Ensure context is properly formatted and sent with prompts
  - Add context search functionality

### 6.3 Response Handling Optimization
- **Implementation Required**:
  - Optimize streaming response handling
  - Ensure proper grouping of responses by promptId
  - Handle error cases gracefully with user feedback
  - Show loading states appropriately

## 7. User Experience Requirements

### 7.1 Interface
- Clean, minimalist design with focus on content
- Clear visual distinction between different model responses
- Responsive layout that works on desktop and tablet
- Intuitive navigation between conversation threads

### 7.2 Performance
- Real-time streaming of responses
- Fast thread switching
- Responsive UI even with multiple model responses
- Efficient token usage tracking

### 7.3 Accessibility
- Clear contrast for readability
- Keyboard navigation support
- Responsive design principles
- Error messages that are clear and actionable

## 8. Security Requirements

### 8.1 Authentication
- JWT token expiration with automatic refresh
- Secure Google OAuth integration
- Protection against token forgery
- Proper session handling

### 8.2 Data Protection
- HTTPS for all communications
- API key protection
- User data isolation
- Access control at organization level

## 9. Development Guidelines

### 9.1 Code Structure
- Clean separation of concerns
- Type safety throughout
- Consistent naming conventions
- Proper error handling at all levels

### 9.2 API Integration Best Practices
- Token refresh middleware for API calls
- Consistent error handling
- Rate limiting awareness
- Proper response parsing

### 9.3 State Management
- Consistent state management patterns
- Clear separation of local vs. global state
- UseEffect dependencies properly managed
- Loading states properly tracked

## 10. Future Enhancements

### 10.1 Advanced Features
- Model performance comparison metrics
- Response rating/feedback system
- Custom system prompts per model
- Advanced context controls

### 10.2 Integration Opportunities
- Export conversations to different formats
- Integration with local LLM runners
- Custom provider API integration
- Team collaboration features

## 11. Implementation Timeline

### Phase 1: Core Functionality
- Multi-model chat interface
- Thread-based conversations
- Basic history management
- Authentication system

### Phase 2: Context & Experience Enhancement
- Context awareness implementation
- UI refinements
- Error handling improvements
- Performance optimizations

### Phase 3: Advanced Features
- Context search functionality
- Advanced history management
- Usage analytics
- Extended model support

## 12. Development Recommendations

1. Fix the threading issue as the highest priority
2. Implement proper context handling
3. Optimize the streaming response system
4. Enhance error handling to provide better user feedback
5. Improve state management to prevent inconsistencies
6. Add comprehensive token usage tracking
7. Enhance the model selection interface with more details
8. Implement response comparison tools

================
File: .cursor/rules/secuirity-rule.mdc
================
---
description: 
globs: 
alwaysApply: true
---
# Security Checklist

## Configuration Security
- [ ] Store secrets in environment variables or dedicated secret management systems
- [ ] Never commit secrets to version control
- [ ] Implement secret rotation policies
- [ ] Use different credentials for different environments
- [ ] Encrypt sensitive configuration values

## Authentication & Authorization
- [ ] Implement proper authentication mechanisms
- [ ] Use OAuth 2.0 or OpenID Connect where appropriate
- [ ] Implement role-based access control (RBAC)
- [ ] Follow the principle of least privilege
- [ ] Implement multi-factor authentication (MFA) for sensitive operations

## Data Protection
- [ ] Encrypt data at rest
- [ ] Encrypt data in transit (TLS/HTTPS)
- [ ] Implement proper key management
- [ ] Sanitize and validate all inputs
- [ ] Implement output encoding to prevent XSS attacks
- [ ] Apply proper database security controls

## API Security
- [ ] Implement rate limiting
- [ ] Set appropriate timeouts
- [ ] Use API keys/tokens with proper scopes
- [ ] Validate and sanitize all API inputs
- [ ] Implement proper error handling that doesn't leak sensitive information

## Infrastructure Security
- [ ] Use container security scanning
- [ ] Implement network segmentation
- [ ] Apply security hardening to containers and hosts
- [ ] Use Web Application Firewalls (WAF) where appropriate
- [ ] Implement proper egress filtering

## Logging & Monitoring
- [ ] Implement security event logging
- [ ] Use centralized log collection and analysis
- [ ] Configure alerts for suspicious activities
- [ ] Implement audit trails for sensitive operations
- [ ] Ensure logs don't contain sensitive information

## Dependency Management
- [ ] Regularly scan dependencies for vulnerabilities
- [ ] Implement a process for updating vulnerable dependencies
- [ ] Use dependency lockfiles for deterministic builds
- [ ] Vet third-party libraries before inclusion
- [ ] Minimize dependency footprint

## Resilience & Availability
- [ ] Implement proper error handling
- [ ] Design for graceful degradation
- [ ] Protect against DoS attacks
- [ ] Implement circuit breakers for external services
- [ ] Have a tested disaster recovery plan

## SDLC Security
- [ ] Perform regular security testing (SAST, DAST, IAST)
- [ ] Implement secure code review processes
- [ ] Conduct regular penetration testing
- [ ] Maintain a vulnerability management program
- [ ] Implement proper CI/CD security controls

## Compliance & Governance
- [ ] Document security controls
- [ ] Implement proper data retention policies
- [ ] Ensure compliance with relevant regulations (GDPR, HIPAA, etc.)
- [ ] Conduct regular security awareness training
- [ ] Establish incident response procedures

================
File: backend/assets/controllers/csrf_protection_controller.js
================
const nameCheck = /^[-_a-zA-Z0-9]{4,22}$/;
const tokenCheck = /^[-_\/+a-zA-Z0-9]{24,}$/;

// Generate and double-submit a CSRF token in a form field and a cookie, as defined by Symfony's SameOriginCsrfTokenManager
document.addEventListener('submit', function (event) {
    generateCsrfToken(event.target);
}, true);

// When @hotwired/turbo handles form submissions, send the CSRF token in a header in addition to a cookie
// The `framework.csrf_protection.check_header` config option needs to be enabled for the header to be checked
document.addEventListener('turbo:submit-start', function (event) {
    const h = generateCsrfHeaders(event.detail.formSubmission.formElement);
    Object.keys(h).map(function (k) {
        event.detail.formSubmission.fetchRequest.headers[k] = h[k];
    });
});

// When @hotwired/turbo handles form submissions, remove the CSRF cookie once a form has been submitted
document.addEventListener('turbo:submit-end', function (event) {
    removeCsrfToken(event.detail.formSubmission.formElement);
});

export function generateCsrfToken (formElement) {
    const csrfField = formElement.querySelector('input[data-controller="csrf-protection"], input[name="_csrf_token"]');

    if (!csrfField) {
        return;
    }

    let csrfCookie = csrfField.getAttribute('data-csrf-protection-cookie-value');
    let csrfToken = csrfField.value;

    if (!csrfCookie && nameCheck.test(csrfToken)) {
        csrfField.setAttribute('data-csrf-protection-cookie-value', csrfCookie = csrfToken);
        csrfField.defaultValue = csrfToken = btoa(String.fromCharCode.apply(null, (window.crypto || window.msCrypto).getRandomValues(new Uint8Array(18))));
        csrfField.dispatchEvent(new Event('change', { bubbles: true }));
    }

    if (csrfCookie && tokenCheck.test(csrfToken)) {
        const cookie = csrfCookie + '_' + csrfToken + '=' + csrfCookie + '; path=/; samesite=strict';
        document.cookie = window.location.protocol === 'https:' ? '__Host-' + cookie + '; secure' : cookie;
    }
}

export function generateCsrfHeaders (formElement) {
    const headers = {};
    const csrfField = formElement.querySelector('input[data-controller="csrf-protection"], input[name="_csrf_token"]');

    if (!csrfField) {
        return headers;
    }

    const csrfCookie = csrfField.getAttribute('data-csrf-protection-cookie-value');

    if (tokenCheck.test(csrfField.value) && nameCheck.test(csrfCookie)) {
        headers[csrfCookie] = csrfField.value;
    }

    return headers;
}

export function removeCsrfToken (formElement) {
    const csrfField = formElement.querySelector('input[data-controller="csrf-protection"], input[name="_csrf_token"]');

    if (!csrfField) {
        return;
    }

    const csrfCookie = csrfField.getAttribute('data-csrf-protection-cookie-value');

    if (tokenCheck.test(csrfField.value) && nameCheck.test(csrfCookie)) {
        const cookie = csrfCookie + '_' + csrfField.value + '=0; path=/; samesite=strict; max-age=0';

        document.cookie = window.location.protocol === 'https:' ? '__Host-' + cookie + '; secure' : cookie;
    }
}

/* stimulusFetch: 'lazy' */
export default 'csrf-protection-controller';

================
File: backend/assets/controllers/hello_controller.js
================
import { Controller } from '@hotwired/stimulus';

/*
 * This is an example Stimulus controller!
 *
 * Any element with a data-controller="hello" attribute will cause
 * this controller to be executed. The name "hello" comes from the filename:
 * hello_controller.js -> "hello"
 *
 * Delete this file or adapt it for your use!
 */
export default class extends Controller {
    connect() {
        this.element.textContent = 'Hello Stimulus! Edit me in assets/controllers/hello_controller.js';
    }
}

================
File: backend/assets/styles/app.css
================
body {
    background-color: skyblue;
}

================
File: backend/assets/app.js
================
import './bootstrap.js';
/*
 * Welcome to your app's main JavaScript file!
 *
 * This file will be included onto the page via the importmap() Twig function,
 * which should already be in your base.html.twig.
 */
import './styles/app.css';

console.log('This log comes from assets/app.js - welcome to AssetMapper! 🎉');

================
File: backend/assets/bootstrap.js
================
import { startStimulusApp } from '@symfony/stimulus-bundle';

const app = startStimulusApp();
// register any custom, 3rd party controllers here
// app.register('some_controller_name', SomeImportedController);

================
File: backend/assets/controllers.json
================
{
    "controllers": {
        "@symfony/ux-turbo": {
            "turbo-core": {
                "enabled": true,
                "fetch": "eager"
            },
            "mercure-turbo-stream": {
                "enabled": false,
                "fetch": "eager"
            }
        }
    },
    "entrypoints": []
}

================
File: backend/bin/console
================
#!/usr/bin/env php
<?php

use App\Kernel;
use Symfony\Bundle\FrameworkBundle\Console\Application;

if (!is_dir(dirname(__DIR__).'/vendor')) {
    throw new LogicException('Dependencies are missing. Try running "composer install".');
}

if (!is_file(dirname(__DIR__).'/vendor/autoload_runtime.php')) {
    throw new LogicException('Symfony Runtime is missing. Try running "composer require symfony/runtime".');
}

require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

return function (array $context) {
    $kernel = new Kernel($context['APP_ENV'], (bool) $context['APP_DEBUG']);

    return new Application($kernel);
};

================
File: backend/bin/phpunit
================
#!/usr/bin/env php
<?php

if (!ini_get('date.timezone')) {
    ini_set('date.timezone', 'UTC');
}

if (is_file(dirname(__DIR__).'/vendor/phpunit/phpunit/phpunit')) {
    if (PHP_VERSION_ID >= 80000) {
        require dirname(__DIR__).'/vendor/phpunit/phpunit/phpunit';
    } else {
        define('PHPUNIT_COMPOSER_INSTALL', dirname(__DIR__).'/vendor/autoload.php');
        require PHPUNIT_COMPOSER_INSTALL;
        PHPUnit\TextUI\Command::main();
    }
} else {
    if (!is_file(dirname(__DIR__).'/vendor/symfony/phpunit-bridge/bin/simple-phpunit.php')) {
        echo "Unable to find the `simple-phpunit.php` script in `vendor/symfony/phpunit-bridge/bin/`.\n";
        exit(1);
    }

    require dirname(__DIR__).'/vendor/symfony/phpunit-bridge/bin/simple-phpunit.php';
}

================
File: backend/config/packages/asset_mapper.yaml
================
framework:
    asset_mapper:
        # The paths to make available to the asset mapper.
        paths:
            - assets/
        missing_import_mode: strict

when@prod:
    framework:
        asset_mapper:
            missing_import_mode: warn

================
File: backend/config/packages/cache.yaml
================
framework:
    cache:
        # Unique name of your app: used to compute stable namespaces for cache keys.
        #prefix_seed: your_vendor_name/app_name

        # The "app" cache stores to the filesystem by default.
        # The data in this cache should persist between deploys.
        # Other options include:

        # Redis
        #app: cache.adapter.redis
        #default_redis_provider: redis://localhost

        # APCu (not recommended with heavy random-write workloads as memory fragmentation can cause perf issues)
        #app: cache.adapter.apcu

        # Namespaced pools use the above "app" backend by default
        #pools:
            #my.dedicated.cache: null

================
File: backend/config/packages/csrf.yaml
================
# Enable stateless CSRF protection for forms and logins/logouts
framework:
    form:
        csrf_protection:
            token_id: submit

    csrf_protection:
        stateless_token_ids:
            - submit
            - authenticate
            - logout

================
File: backend/config/packages/debug.yaml
================
when@dev:
    debug:
        # Forwards VarDumper Data clones to a centralized server allowing to inspect dumps on CLI or in your browser.
        # See the "server:dump" command to start a new server.
        dump_destination: "tcp://%env(VAR_DUMPER_SERVER)%"

================
File: backend/config/packages/doctrine_migrations.yaml
================
doctrine_migrations:
    migrations_paths:
        # namespace is arbitrary but should be different from App\Migrations
        # as migrations classes should NOT be autoloaded
        'DoctrineMigrations': '%kernel.project_dir%/migrations'
    enable_profiler: false

================
File: backend/config/packages/doctrine.yaml
================
doctrine:
    dbal:
        url: '%env(resolve:DATABASE_URL)%'

        # IMPORTANT: You MUST configure your server version,
        # either here or in the DATABASE_URL env var (see .env file)
        server_version: '8.0'

        profiling_collect_backtrace: '%kernel.debug%'
        use_savepoints: true
    orm:
        auto_generate_proxy_classes: true
        enable_lazy_ghost_objects: true
        report_fields_where_declared: true
        validate_xml_mapping: true
        naming_strategy: doctrine.orm.naming_strategy.underscore_number_aware
        identity_generation_preferences:
            Doctrine\DBAL\Platforms\PostgreSQLPlatform: identity
        auto_mapping: true
        mappings:
            App:
                type: attribute
                is_bundle: false
                dir: '%kernel.project_dir%/src/Entity'
                prefix: 'App\Entity'
                alias: App
        controller_resolver:
            auto_mapping: false

when@test:
    doctrine:
        dbal:
            # "TEST_TOKEN" is typically set by ParaTest
            dbname_suffix: '_test%env(default::TEST_TOKEN)%'

when@prod:
    doctrine:
        orm:
            auto_generate_proxy_classes: false
            proxy_dir: '%kernel.build_dir%/doctrine/orm/Proxies'
            query_cache_driver:
                type: pool
                pool: doctrine.system_cache_pool
            result_cache_driver:
                type: pool
                pool: doctrine.result_cache_pool

    framework:
        cache:
            pools:
                doctrine.result_cache_pool:
                    adapter: cache.app
                doctrine.system_cache_pool:
                    adapter: cache.system

================
File: backend/config/packages/framework.yaml
================
# see https://symfony.com/doc/current/reference/configuration/framework.html
framework:
    secret: '%env(APP_SECRET)%'

    # Note that the session will be started ONLY if you read or write from it.
    session: true

    #esi: true
    #fragments: true

when@test:
    framework:
        test: true
        session:
            storage_factory_id: session.storage.factory.mock_file

================
File: backend/config/packages/knpu_oauth2_client.yaml
================
knpu_oauth2_client:
    clients:
        google:
            type: google
            client_id: '%env(GOOGLE_CLIENT_ID)%'
            client_secret: '%env(GOOGLE_CLIENT_SECRET)%'
            redirect_route: connect_google_check
            redirect_params: {}

================
File: backend/config/packages/lexik_jwt_authentication.yaml
================
lexik_jwt_authentication:
    secret_key: '%env(resolve:JWT_SECRET_KEY)%'
    public_key: '%env(resolve:JWT_PUBLIC_KEY)%'
    pass_phrase: '%env(JWT_PASSPHRASE)%'

================
File: backend/config/packages/mailer.yaml
================
framework:
    mailer:
        dsn: '%env(MAILER_DSN)%'

================
File: backend/config/packages/messenger.yaml
================
framework:
    messenger:
        failure_transport: failed

        transports:
            # https://symfony.com/doc/current/messenger.html#transport-configuration
            async:
                dsn: '%env(MESSENGER_TRANSPORT_DSN)%'
                options:
                    use_notify: true
                    check_delayed_interval: 60000
                retry_strategy:
                    max_retries: 3
                    multiplier: 2
            failed: 'doctrine://default?queue_name=failed'
            # sync: 'sync://'

        default_bus: messenger.bus.default

        buses:
            messenger.bus.default: []

        routing:
            Symfony\Component\Mailer\Messenger\SendEmailMessage: async
            Symfony\Component\Notifier\Message\ChatMessage: async
            Symfony\Component\Notifier\Message\SmsMessage: async

            # Route your messages to the transports
            # 'App\Message\YourMessage': async

================
File: backend/config/packages/monolog.yaml
================
monolog:
    channels:
        - deprecation # Deprecations are logged in the dedicated "deprecation" channel when it exists

when@dev:
    monolog:
        handlers:
            main:
                type: stream
                path: "%kernel.logs_dir%/%kernel.environment%.log"
                level: debug
                channels: ["!event"]
            # uncomment to get logging in your browser
            # you may have to allow bigger header sizes in your Web server configuration
            #firephp:
            #    type: firephp
            #    level: info
            #chromephp:
            #    type: chromephp
            #    level: info
            console:
                type: console
                process_psr_3_messages: false
                channels: ["!event", "!doctrine", "!console"]

when@test:
    monolog:
        handlers:
            main:
                type: fingers_crossed
                action_level: error
                handler: nested
                excluded_http_codes: [404, 405]
                channels: ["!event"]
            nested:
                type: stream
                path: "%kernel.logs_dir%/%kernel.environment%.log"
                level: debug

when@prod:
    monolog:
        handlers:
            main:
                type: fingers_crossed
                action_level: error
                handler: nested
                excluded_http_codes: [404, 405]
                buffer_size: 50 # How many messages should be saved? Prevent memory leaks
            nested:
                type: stream
                path: php://stderr
                level: debug
                formatter: monolog.formatter.json
            console:
                type: console
                process_psr_3_messages: false
                channels: ["!event", "!doctrine"]
            deprecation:
                type: stream
                channels: [deprecation]
                path: php://stderr
                formatter: monolog.formatter.json

================
File: backend/config/packages/nelmio_cors.yaml
================
nelmio_cors:
    defaults:
        origin_regex: true
        allow_origin: ['%env(CORS_ALLOW_ORIGIN)%']
        allow_methods: ['GET', 'OPTIONS', 'POST', 'PUT', 'PATCH', 'DELETE']
        allow_headers: ['Content-Type', 'Authorization', 'Accept', 'X-Requested-With']
        expose_headers: ['Link']
        max_age: 3600
    paths:
        '^/api/':
            allow_origin: ['%env(CORS_ALLOW_ORIGIN)%']
            allow_headers: ['Content-Type', 'Authorization', 'Accept', 'X-Requested-With']
            allow_methods: ['POST', 'PUT', 'GET', 'DELETE', 'OPTIONS']
            allow_credentials: true
            max_age: 3600
        '^/connect/':
            allow_origin: ['%env(CORS_ALLOW_ORIGIN)%']
            allow_headers: ['Content-Type', 'Authorization', 'Accept', 'X-Requested-With']
            allow_methods: ['GET', 'OPTIONS']
            allow_credentials: true
            max_age: 3600

================
File: backend/config/packages/notifier.yaml
================
framework:
    notifier:
        chatter_transports:
        texter_transports:
        channel_policy:
            # use chat/slack, chat/telegram, sms/twilio or sms/nexmo
            urgent: ['email']
            high: ['email']
            medium: ['email']
            low: ['email']
        admin_recipients:
            - { email: admin@example.com }

================
File: backend/config/packages/routing.yaml
================
framework:
    router:
        # Configure how to generate URLs in non-HTTP contexts, such as CLI commands.
        # See https://symfony.com/doc/current/routing.html#generating-urls-in-commands
        #default_uri: http://localhost

when@prod:
    framework:
        router:
            strict_requirements: null

================
File: backend/config/packages/security.yaml
================
security:
    password_hashers:
        Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: 'auto'
    providers:
        app_user_provider:
            entity:
                class: App\Entity\User
                property: googleId
    
    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false
        api:
            pattern: ^/api
            stateless: true
            custom_authenticators:
                - App\Security\JWTAuthenticator
        main:
            lazy: true
            provider: app_user_provider
            custom_authenticators:
                - App\Security\GoogleAuthenticator
            logout:
                path: app_logout
                target: app_home
    
    access_control:
        - { path: ^/login, roles: PUBLIC_ACCESS }
        - { path: ^/connect/google, roles: PUBLIC_ACCESS }
        - { path: ^/api/public, roles: PUBLIC_ACCESS }
        - { path: ^/api/token/refresh, roles: PUBLIC_ACCESS }
        - { path: ^/api, roles: ROLE_USER }
        - { path: ^/admin, roles: ROLE_ADMIN }
        - { path: ^/profile, roles: ROLE_USER }

when@test:
    security:
        password_hashers:
            Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface:
                algorithm: auto
                cost: 4
                time_cost: 3
                memory_cost: 10

================
File: backend/config/packages/translation.yaml
================
framework:
    default_locale: en
    translator:
        default_path: '%kernel.project_dir%/translations'
        fallbacks:
            - en
        providers:

================
File: backend/config/packages/twig.yaml
================
twig:
    file_name_pattern: '*.twig'

when@test:
    twig:
        strict_variables: true

================
File: backend/config/packages/validator.yaml
================
framework:
    validation:
        # Enables validator auto-mapping support.
        # For instance, basic validation constraints will be inferred from Doctrine's metadata.
        #auto_mapping:
        #    App\Entity\: []

when@test:
    framework:
        validation:
            not_compromised_password: false

================
File: backend/config/packages/web_profiler.yaml
================
when@dev:
    web_profiler:
        toolbar: true

    framework:
        profiler:
            collect_serializer_data: true

when@test:
    framework:
        profiler: { collect: false }

================
File: backend/config/routes/framework.yaml
================
when@dev:
    _errors:
        resource: '@FrameworkBundle/Resources/config/routing/errors.xml'
        prefix: /_error

================
File: backend/config/routes/security.yaml
================
_security_logout:
    resource: security.route_loader.logout
    type: service

================
File: backend/config/routes/web_profiler.yaml
================
when@dev:
    web_profiler_wdt:
        resource: '@WebProfilerBundle/Resources/config/routing/wdt.xml'
        prefix: /_wdt

    web_profiler_profiler:
        resource: '@WebProfilerBundle/Resources/config/routing/profiler.xml'
        prefix: /_profiler

================
File: backend/config/bundles.php
================
<?php

return [
    Symfony\Bundle\FrameworkBundle\FrameworkBundle::class => ['all' => true],
    Doctrine\Bundle\DoctrineBundle\DoctrineBundle::class => ['all' => true],
    Doctrine\Bundle\MigrationsBundle\DoctrineMigrationsBundle::class => ['all' => true],
    Symfony\Bundle\DebugBundle\DebugBundle::class => ['dev' => true],
    Symfony\Bundle\TwigBundle\TwigBundle::class => ['all' => true],
    Symfony\Bundle\WebProfilerBundle\WebProfilerBundle::class => ['dev' => true, 'test' => true],
    Symfony\UX\StimulusBundle\StimulusBundle::class => ['all' => true],
    Symfony\UX\Turbo\TurboBundle::class => ['all' => true],
    Twig\Extra\TwigExtraBundle\TwigExtraBundle::class => ['all' => true],
    Symfony\Bundle\SecurityBundle\SecurityBundle::class => ['all' => true],
    Symfony\Bundle\MonologBundle\MonologBundle::class => ['all' => true],
    Symfony\Bundle\MakerBundle\MakerBundle::class => ['dev' => true],
    Nelmio\CorsBundle\NelmioCorsBundle::class => ['all' => true],
    KnpU\OAuth2ClientBundle\KnpUOAuth2ClientBundle::class => ['all' => true],
    Lexik\Bundle\JWTAuthenticationBundle\LexikJWTAuthenticationBundle::class => ['all' => true],
];

================
File: backend/config/preload.php
================
<?php

if (file_exists(dirname(__DIR__).'/var/cache/prod/App_KernelProdContainer.preload.php')) {
    require dirname(__DIR__).'/var/cache/prod/App_KernelProdContainer.preload.php';
}

================
File: backend/config/routes.yaml
================
controllers:
    resource:
        path: ../src/Controller/
        namespace: App\Controller
    type: attribute

app_logout:
    path: /logout

================
File: backend/config/services.yaml
================
# This file is the entry point to configure your own services.
# Files in the packages/ subdirectory configure your dependencies.

# Put parameters here that don't need to change on each machine where the app is deployed
# https://symfony.com/doc/current/best_practices.html#use-parameters-for-application-configuration
parameters:
    frontend_url: '%env(FRONTEND_URL)%'
    openrouter_api_key: '%env(OPENROUTER_API_KEY)%'
    openrouter_cache_ttl: '%env(int:OPENROUTER_CACHE_TTL)%'

services:
    # default configuration for services in *this* file
    _defaults:
        autowire: true      # Automatically injects dependencies in your services.
        autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.

    # makes classes in src/ available to be used as services
    # this creates a service per class whose id is the fully-qualified class name
    App\:
        resource: '../src/'
        exclude:
            - '../src/DependencyInjection/'
            - '../src/Entity/'
            - '../src/Kernel.php'

    # add more service definitions when explicit configuration is needed
    # please note that last definitions always *replace* previous ones
    
    App\Service\OpenRouterService:
        arguments:
            $apiKey: '%openrouter_api_key%'
            
    # Cache adapter for models
    models.cache:
        class: Symfony\Component\Cache\Adapter\FilesystemAdapter
        arguments:
            $namespace: 'models'
            $defaultLifetime: '%openrouter_cache_ttl%'
            
    App\Service\ModelService:
        arguments:
            $cache: '@models.cache'
            $cacheTtl: '%openrouter_cache_ttl%'

================
File: backend/migrations/Version20250325192728.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250325192728 extends AbstractMigration
{
    public function getDescription(): string
    {
        return '';
    }

    public function up(Schema $schema): void
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('CREATE TABLE chat_history (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, prompt LONGTEXT NOT NULL, responses JSON NOT NULL, created_at DATETIME NOT NULL, INDEX IDX_6BB4BC22A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');
        $this->addSql('CREATE TABLE organization (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, google_id VARCHAR(255) NOT NULL, INDEX IDX_C1EE637CA76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');
        $this->addSql('CREATE TABLE user (id INT AUTO_INCREMENT NOT NULL, organization_id INT NOT NULL, google_id VARCHAR(255) NOT NULL, roles JSON NOT NULL, email VARCHAR(255) NOT NULL, UNIQUE INDEX UNIQ_8D93D64976F5C865 (google_id), INDEX IDX_8D93D64932C8A3DE (organization_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');
        $this->addSql('CREATE TABLE messenger_messages (id BIGINT AUTO_INCREMENT NOT NULL, body LONGTEXT NOT NULL, headers LONGTEXT NOT NULL, queue_name VARCHAR(190) NOT NULL, created_at DATETIME NOT NULL COMMENT \'(DC2Type:datetime_immutable)\', available_at DATETIME NOT NULL COMMENT \'(DC2Type:datetime_immutable)\', delivered_at DATETIME DEFAULT NULL COMMENT \'(DC2Type:datetime_immutable)\', INDEX IDX_75EA56E0FB7336F0 (queue_name), INDEX IDX_75EA56E0E3BD61CE (available_at), INDEX IDX_75EA56E016BA31DB (delivered_at), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');
        $this->addSql('ALTER TABLE chat_history ADD CONSTRAINT FK_6BB4BC22A76ED395 FOREIGN KEY (user_id) REFERENCES user (id)');
        $this->addSql('ALTER TABLE organization ADD CONSTRAINT FK_C1EE637CA76ED395 FOREIGN KEY (user_id) REFERENCES user (id)');
        $this->addSql('ALTER TABLE user ADD CONSTRAINT FK_8D93D64932C8A3DE FOREIGN KEY (organization_id) REFERENCES organization (id)');
    }

    public function down(Schema $schema): void
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_history DROP FOREIGN KEY FK_6BB4BC22A76ED395');
        $this->addSql('ALTER TABLE organization DROP FOREIGN KEY FK_C1EE637CA76ED395');
        $this->addSql('ALTER TABLE user DROP FOREIGN KEY FK_8D93D64932C8A3DE');
        $this->addSql('DROP TABLE chat_history');
        $this->addSql('DROP TABLE organization');
        $this->addSql('DROP TABLE user');
        $this->addSql('DROP TABLE messenger_messages');
    }
}

================
File: backend/migrations/Version20250325193147.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250325193147 extends AbstractMigration
{
    public function getDescription(): string
    {
        return '';
    }

    public function up(Schema $schema): void
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE organization ADD domain VARCHAR(255) DEFAULT NULL, ADD usage_count INT NOT NULL');
        $this->addSql('ALTER TABLE user CHANGE organization_id organization_id INT DEFAULT NULL');
    }

    public function down(Schema $schema): void
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE organization DROP domain, DROP usage_count');
        $this->addSql('ALTER TABLE user CHANGE organization_id organization_id INT NOT NULL');
    }
}

================
File: backend/migrations/Version20250326154313.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250326154313 extends AbstractMigration
{
    public function getDescription(): string
    {
        return '';
    }

    public function up(Schema $schema): void
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_history ADD parent_id INT DEFAULT NULL, ADD thread_id VARCHAR(255) DEFAULT NULL');
        $this->addSql('ALTER TABLE chat_history ADD CONSTRAINT FK_6BB4BC22727ACA70 FOREIGN KEY (parent_id) REFERENCES chat_history (id)');
        $this->addSql('CREATE INDEX IDX_6BB4BC22727ACA70 ON chat_history (parent_id)');
    }

    public function down(Schema $schema): void
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_history DROP FOREIGN KEY FK_6BB4BC22727ACA70');
        $this->addSql('DROP INDEX IDX_6BB4BC22727ACA70 ON chat_history');
        $this->addSql('ALTER TABLE chat_history DROP parent_id, DROP thread_id');
    }
}

================
File: backend/migrations/Version20250326163907.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250326163907 extends AbstractMigration
{
    public function getDescription(): string
    {
        return 'Create Thread entity and update ChatHistory structure';
    }

    public function up(Schema $schema): void
    {
        // Create thread table
        $this->addSql('CREATE TABLE thread (
            id INT AUTO_INCREMENT NOT NULL,
            user_id INT NOT NULL,
            created_at DATETIME NOT NULL,
            thread_id VARCHAR(255) NOT NULL,
            INDEX IDX_31204C83A76ED395 (user_id),
            UNIQUE INDEX UNIQ_31204C83E9B8B8B8 (thread_id),
            PRIMARY KEY(id)
        ) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');

        // Drop old columns from chat_history
        $this->addSql('ALTER TABLE chat_history DROP FOREIGN KEY FK_6BB4BC22A76ED395');
        $this->addSql('ALTER TABLE chat_history DROP FOREIGN KEY FK_6BB4BC22727ACA70');
        $this->addSql('ALTER TABLE chat_history DROP user_id, DROP thread_id, DROP parent_id');

        // Add new columns to chat_history
        $this->addSql('ALTER TABLE chat_history 
            ADD thread_id INT NOT NULL AFTER id,
            ADD model_id VARCHAR(255) NOT NULL AFTER responses,
            ADD open_router_id VARCHAR(255) DEFAULT NULL AFTER model_id,
            ADD INDEX IDX_6BB4BC22E9B8B8B8 (thread_id)');

        // Add foreign key for thread
        $this->addSql('ALTER TABLE chat_history 
            ADD CONSTRAINT FK_6BB4BC22E9B8B8B8 
            FOREIGN KEY (thread_id) REFERENCES thread (id)');

        // Add foreign key for thread -> user
        $this->addSql('ALTER TABLE thread 
            ADD CONSTRAINT FK_31204C83A76ED395 
            FOREIGN KEY (user_id) REFERENCES user (id)');
    }

    public function down(Schema $schema): void
    {
        // Remove foreign keys
        $this->addSql('ALTER TABLE chat_history DROP FOREIGN KEY FK_6BB4BC22E9B8B8B8');
        $this->addSql('ALTER TABLE thread DROP FOREIGN KEY FK_31204C83A76ED395');

        // Drop thread table
        $this->addSql('DROP TABLE thread');

        // Restore old columns in chat_history
        $this->addSql('ALTER TABLE chat_history 
            ADD user_id INT DEFAULT NULL AFTER id,
            ADD thread_id VARCHAR(255) DEFAULT NULL AFTER user_id,
            ADD parent_id INT DEFAULT NULL AFTER thread_id,
            DROP model_id,
            DROP open_router_id,
            DROP INDEX IDX_6BB4BC22E9B8B8B8');

        // Restore foreign key for user
        $this->addSql('ALTER TABLE chat_history 
            ADD CONSTRAINT FK_6BB4BC22A76ED395 
            FOREIGN KEY (user_id) REFERENCES user (id)');
    }
}

================
File: backend/migrations/Version20250326165958.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250326165958 extends AbstractMigration
{
    public function getDescription(): string
    {
        return '';
    }

    public function up(Schema $schema): void
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_history ADD response LONGTEXT NOT NULL, DROP responses');
        $this->addSql('ALTER TABLE chat_history RENAME INDEX idx_6bb4bc22e9b8b8b8 TO IDX_6BB4BC22E2904019');
        $this->addSql('ALTER TABLE thread RENAME INDEX uniq_31204c83e9b8b8b8 TO UNIQ_31204C83E2904019');
    }

    public function down(Schema $schema): void
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE thread RENAME INDEX uniq_31204c83e2904019 TO UNIQ_31204C83E9B8B8B8');
        $this->addSql('ALTER TABLE chat_history ADD responses JSON NOT NULL, DROP response');
        $this->addSql('ALTER TABLE chat_history RENAME INDEX idx_6bb4bc22e2904019 TO IDX_6BB4BC22E9B8B8B8');
    }
}

================
File: backend/migrations/Version20250326170154.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250326170154 extends AbstractMigration
{
    public function getDescription(): string
    {
        return '';
    }

    public function up(Schema $schema): void
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_history CHANGE response response JSON NOT NULL');
    }

    public function down(Schema $schema): void
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_history CHANGE response response LONGTEXT NOT NULL');
    }
}

================
File: backend/migrations/Version20250327100649.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250327100649 extends AbstractMigration
{
    public function getDescription(): string
    {
        return '';
    }

    public function up(Schema $schema): void
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_history ADD prompt_id VARCHAR(255) NOT NULL');
    }

    public function down(Schema $schema): void
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_history DROP prompt_id');
    }
}

================
File: backend/migrations/Version20250327102737.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250327102737 extends AbstractMigration
{
    public function getDescription(): string
    {
        return '';
    }

    public function up(Schema $schema): void
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE thread ADD title VARCHAR(255) NOT NULL');
    }

    public function down(Schema $schema): void
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE thread DROP title');
    }
}

================
File: backend/migrations/Version20250327224028.php
================
<?php

declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
final class Version20250327224028 extends AbstractMigration
{
    public function getDescription(): string
    {
        return '';
    }

    public function up(Schema $schema): void
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('CREATE TABLE chat_cost (id INT AUTO_INCREMENT NOT NULL, chat_history_id INT NOT NULL, total_cost DOUBLE PRECISION NOT NULL, created_at DATETIME NOT NULL, open_router_id VARCHAR(255) NOT NULL, model VARCHAR(255) NOT NULL, origin VARCHAR(255) DEFAULT NULL, `total_usage` DOUBLE PRECISION DEFAULT NULL, is_byok TINYINT(1) NOT NULL, upstream_id VARCHAR(255) DEFAULT NULL, cache_discount DOUBLE PRECISION DEFAULT NULL, app_id INT DEFAULT NULL, streamed TINYINT(1) NOT NULL, cancelled TINYINT(1) NOT NULL, provider_name VARCHAR(255) DEFAULT NULL, latency INT DEFAULT NULL, moderation_latency INT DEFAULT NULL, generation_time INT DEFAULT NULL, finish_reason VARCHAR(255) DEFAULT NULL, native_finish_reason VARCHAR(255) DEFAULT NULL, tokens_prompt INT DEFAULT NULL, tokens_completion INT DEFAULT NULL, native_tokens_prompt INT DEFAULT NULL, native_tokens_completion INT DEFAULT NULL, native_tokens_reasoning INT DEFAULT NULL, num_media_prompt INT DEFAULT NULL, num_media_completion INT DEFAULT NULL, num_search_results INT DEFAULT NULL, INDEX IDX_BEBA09BDD9F4C1F4 (chat_history_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');
        $this->addSql('ALTER TABLE chat_cost ADD CONSTRAINT FK_BEBA09BDD9F4C1F4 FOREIGN KEY (chat_history_id) REFERENCES chat_history (id)');
    }

    public function down(Schema $schema): void
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE chat_cost DROP FOREIGN KEY FK_BEBA09BDD9F4C1F4');
        $this->addSql('DROP TABLE chat_cost');
    }
}

================
File: backend/public/index.php
================
<?php

use App\Kernel;

require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

return function (array $context) {
    return new Kernel($context['APP_ENV'], (bool) $context['APP_DEBUG']);
};

================
File: backend/src/Command/CacheModelsCommand.php
================
<?php

namespace App\Command;

use App\Service\ModelService;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;

#[AsCommand(
    name: 'app:cache:models',
    description: 'Refresh the OpenRouter models cache',
)]
class CacheModelsCommand extends Command
{
    private ModelService $modelService;

    public function __construct(ModelService $modelService)
    {
        parent::__construct();
        $this->modelService = $modelService;
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);

        $io->info('Refreshing OpenRouter models cache...');
        
        try {
            $models = $this->modelService->refreshModels();
            $io->success(sprintf('Successfully cached %d models', count($models)));
            return Command::SUCCESS;
        } catch (\Exception $e) {
            $io->error('Failed to refresh models cache: ' . $e->getMessage());
            return Command::FAILURE;
        }
    }
}

================
File: backend/src/Command/GenerateJwtCommand.php
================
<?php

namespace App\Command;

use App\Entity\User;
use App\Service\JWTService;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

#[AsCommand(
    name: 'app:generate-jwt',
    description: 'Generate a JWT token for a user',
)]
class GenerateJwtCommand extends Command
{
    public function __construct(
        private EntityManagerInterface $entityManager,
        private JWTService $jwtService
    ) {
        parent::__construct();
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $userRepository = $this->entityManager->getRepository(User::class);
        $user = $userRepository->findOneBy([]);

        if (!$user) {
            $output->writeln('No user found in the database.');
            return Command::FAILURE;
        }

        $token = $this->jwtService->createToken($user);

        $output->writeln("JWT Token for user {$user->getEmail()}:");
        $output->writeln($token);

        return Command::SUCCESS;
    }
}

================
File: backend/src/Command/CheckOpenRouterCostsCommand.php
================
<?php

namespace App\Command;

use App\Entity\ChatCost;
use App\Entity\ChatHistory;
use App\Service\OpenRouterService;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Console\Attribute\AsCommand;

#[AsCommand(
    name: 'app:check-openrouter-costs',
    description: 'Check OpenRouter costs for chat history',
)]
class CheckOpenRouterCostsCommand extends Command
{
    public function __construct(
        private EntityManagerInterface $entityManager,
        private OpenRouterService $openRouterService
    ) {
        parent::__construct();
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        $io->title('Checking OpenRouter costs...');

        // Get all chat histories with openRouterId
        $chatHistories = $this->entityManager->getRepository(ChatHistory::class)
            ->createQueryBuilder('ch')
            ->where('ch.openRouterId IS NOT NULL')
            ->getQuery()
            ->getResult();

        $io->progressStart(count($chatHistories));
        $totalCost = 0;

        foreach ($chatHistories as $chatHistory) {
            try {
                $data = $this->openRouterService->getGenerationData($chatHistory->getOpenRouterId());
                
                // Find existing cost or create new one
                $chatCost = $this->entityManager->getRepository(ChatCost::class)
                    ->findOneBy(['openRouterId' => $chatHistory->getOpenRouterId()]);
                
                if (!$chatCost) {
                    $chatCost = new ChatCost();
                }
                
                $chatCost->setChatHistory($chatHistory)
                    ->setTotalCost($data['total_cost'] ?? 0.0)
                    ->setOpenRouterId($chatHistory->getOpenRouterId())
                    ->setModel($data['model'] ?? '')
                    ->setOrigin($data['origin'] ?? null)
                    ->setTotalUsage($data['usage'] ?? null)
                    ->setIsByok($data['is_byok'] ?? false)
                    ->setUpstreamId($data['upstream_id'] ?? null)
                    ->setCacheDiscount($data['cache_discount'] ?? null)
                    ->setAppId($data['app_id'] ?? null)
                    ->setStreamed($data['streamed'] ?? false)
                    ->setCancelled($data['cancelled'] ?? false)
                    ->setProviderName($data['provider_name'] ?? null)
                    ->setLatency($data['latency'] ?? null)
                    ->setModerationLatency($data['moderation_latency'] ?? null)
                    ->setGenerationTime($data['generation_time'] ?? null)
                    ->setFinishReason($data['finish_reason'] ?? null)
                    ->setNativeFinishReason($data['native_finish_reason'] ?? null)
                    ->setTokensPrompt($data['tokens_prompt'] ?? null)
                    ->setTokensCompletion($data['tokens_completion'] ?? null)
                    ->setNativeTokensPrompt($data['native_tokens_prompt'] ?? null)
                    ->setNativeTokensCompletion($data['native_tokens_completion'] ?? null)
                    ->setNativeTokensReasoning($data['native_tokens_reasoning'] ?? null)
                    ->setNumMediaPrompt($data['num_media_prompt'] ?? null)
                    ->setNumMediaCompletion($data['num_media_completion'] ?? null)
                    ->setNumSearchResults($data['num_search_results'] ?? null);
                
                $this->entityManager->persist($chatCost);
                $totalCost += $data['total_cost'] ?? 0.0;

                // Show detailed info for each generation
                $io->writeln(sprintf(
                    "\nGeneration %s:\n- Cost: $%.4f\n- Model: %s\n- Provider: %s\n- Tokens: %d prompt, %d completion\n- Cache discount: %.2f%%",
                    $chatHistory->getOpenRouterId(),
                    $data['total_cost'] ?? 0.0,
                    $data['model'] ?? 'unknown',
                    $data['provider_name'] ?? 'unknown',
                    $data['tokens_prompt'] ?? 0,
                    $data['tokens_completion'] ?? 0,
                    ($data['cache_discount'] ?? 0) * 100
                ));
            } catch (\Exception $e) {
                $io->error(sprintf('Error getting data for chat history %d: %s', $chatHistory->getId(), $e->getMessage()));
            }
            
            $io->progressAdvance();
        }

        $this->entityManager->flush();
        $io->progressFinish();
        
        $io->success([
            sprintf('Total cost: $%.4f', $totalCost),
            sprintf('Processed %d generations', count($chatHistories))
        ]);
        
        return Command::SUCCESS;
    }
}

================
File: backend/src/Controller/GoogleController.php
================
<?php

namespace App\Controller;

use App\Service\JWTService;
use KnpU\OAuth2ClientBundle\Client\ClientRegistry;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Psr\Log\LoggerInterface;

class GoogleController extends AbstractController
{
    private LoggerInterface $logger;
    
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }
    
    #[Route('/connect/google', name: 'connect_google')]
    public function connectAction(ClientRegistry $clientRegistry): \Symfony\Component\HttpFoundation\RedirectResponse
    {
        return $clientRegistry
            ->getClient('google') // key used in config/packages/knpu_oauth2_client.yaml
            ->redirect([
                'email' // the scopes you want to access
            ]);
    }

    #[Route('/connect/google/check', name: 'connect_google_check')]
    public function checkAction(Request $request, JWTService $jwtService): Response
    {
        // This method is called after Google redirects back to your app
        
        // Get the authenticated user
        $user = $this->getUser();
        
        if (!$user) {
            // Redirect to frontend with error
            return $this->redirect(
                ($_ENV['FRONTEND_URL'] ?? 'http://localhost:5173') . '/callback?error=authentication_failed'
            );
        }
        
        try {
            // Create JWT token
            $token = $jwtService->createToken($user);
            
            // Redirect to frontend with token
            return $this->redirect(
                ($_ENV['FRONTEND_URL'] ?? 'http://localhost:5173') . '/callback?token=' . $token
            );
        } catch (\Exception $e) {
            // Log the error
            $this->logger->error('JWT token creation failed: ' . $e->getMessage());
            
            // Redirect to login with error
            return $this->redirect(
                ($_ENV['FRONTEND_URL'] ?? 'http://localhost:5173') . '/callback?error=token_creation_failed'
            );
        }
    }
}

================
File: backend/src/Controller/HomeController.php
================
<?php

namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class HomeController extends AbstractController
{
    #[Route('/', name: 'app_home')]
    public function index(): Response
    {
        // Redirect to frontend instead of rendering a template
        return $this->redirect($this->getParameter('frontend_url'));
    }
}

================
File: backend/src/Controller/ChatController.php
================
<?php

namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;
use App\Service\OpenRouterService;
use App\Service\ModelService;
use Doctrine\ORM\EntityManagerInterface;
use App\Entity\ChatHistory;
use Symfony\Component\Serializer\SerializerInterface;
use App\Entity\Thread;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\HttpFoundation\StreamedResponse;

#[Route('/api')]
class ChatController extends AbstractController
{
    #[Route('/models', methods: ['GET'])]
    public function getModels(ModelService $modelService): JsonResponse
    {
        return $this->json($modelService->getModels());
    }
    
    #[Route('/models/refresh', methods: ['GET'])]
    public function refreshModels(ModelService $modelService): JsonResponse
    {
        return $this->json($modelService->refreshModels());
    }

    #[Route('/chat', methods: ['POST'])]
    public function chat(Request $request, EntityManagerInterface $em, OpenRouterService $openRouter): Response
    {
        $data = json_decode($request->getContent(), true);
        $prompt = $data['prompt'] ?? null;
        $models = $data['models'] ?? [];
        $threadId = $data['threadId'] ?? null;
        $stream = $data['stream'] ?? false;
        $promptId = $data['promptId'] ?? null;
        
        if (!$prompt || empty($models)) {
            throw new HttpException(400, 'Prompt and models are required');
        }
    
        if (!$promptId) {
            throw new HttpException(400, 'PromptId is required');
        }
        
        $user = $this->getUser();
        $organization = $user->getOrganization();
        
        // Handle thread creation or retrieval
        if ($threadId) {
            // If thread ID is provided, use it
            $thread = $em->getRepository(Thread::class)->findOneBy(['threadId' => $threadId]);
            if (!$thread) {
                throw new HttpException(404, 'Thread not found');
            }
        } else {
            // No thread ID provided - create exactly one new thread
            $thread = new Thread();
            $thread->setTitle(substr($prompt, 0, 100));
            $thread->setUser($user);
            $thread->setThreadId(uniqid('thread_', true));
            $em->persist($thread);
            $em->flush(); // Flush immediately to ensure thread is saved
            
            // Get the thread ID to reuse with all models
            $threadId = $thread->getThreadId();
        }
    
        if ($stream) {
            // For streaming, we'll handle one model at a time
            $modelId = $models[0]; // Get first model for streaming
            $modelResponses = $openRouter->streamResponse($prompt, [$modelId]);
            
            if (!isset($modelResponses[$modelId])) {
                throw new HttpException(500, 'Failed to generate streaming response');
            }
    
            $modelResponse = $modelResponses[$modelId];
            
            // Create a new StreamedResponse
            $response = new StreamedResponse(function() use ($modelResponse, $modelId, $prompt, $thread, $em, $promptId) {
                $stream = $modelResponse['stream'];
                $content = '';
                $openRouterId = null;
                $historySaved = false;
                
                while (!feof($stream)) {
                    $chunk = fread($stream, 8192);
                    if ($chunk === false) break;
                    
                    $lines = explode("\n", $chunk);
                    foreach ($lines as $line) {
                        if (empty(trim($line))) continue;
                        if (strpos($line, 'data: ') === 0) {
                            $data = substr($line, 6);
                            if ($data === '[DONE]') {
                                // Save the complete response to chat history
                                $chatHistory = new ChatHistory();
                                $chatHistory->setThread($thread)
                                    ->setPrompt($prompt)
                                    ->setPromptId($promptId)
                                    ->setResponse([
                                        'content' => $content,
                                        'usage' => [
                                            'prompt_tokens' => 0,
                                            'completion_tokens' => 0,
                                            'total_tokens' => 0
                                        ]
                                    ])
                                    ->setModelId($modelId)
                                    ->setOpenRouterId($openRouterId);
                                
                                $em->persist($chatHistory);
                                $em->flush();
                                $historySaved = true;
                                
                                echo "data: " . json_encode([
                                    'done' => true, 
                                    'modelId' => $modelId, 
                                    'threadId' => $thread->getThreadId(),
                                    'promptId' => $promptId,
                                    'content' => $content,
                                    'usage' => [
                                        'prompt_tokens' => 0,
                                        'completion_tokens' => 0,
                                        'total_tokens' => 0
                                    ]
                                ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) . "\n\n";
                                flush();
                                continue;
                            }
                            
                            try {
                                $parsed = json_decode($data, true);
                                if (isset($parsed['id'])) {
                                    $openRouterId = $parsed['id'];
                                    echo "data: " . json_encode(['id' => $openRouterId]) . "\n\n";
                                    flush();
                                }
                                if (isset($parsed['choices'][0]['delta']['content'])) {
                                    $content .= $parsed['choices'][0]['delta']['content'];
                                    echo "data: " . json_encode([
                                        'content' => $parsed['choices'][0]['delta']['content'],
                                        'modelId' => $modelId,
                                        'threadId' => $thread->getThreadId(),
                                        'promptId' => $promptId
                                    ], JSON_UNESCAPED_UNICODE) . "\n\n";
                                    flush();
                                }
                                if (isset($parsed['choices'][0]['delta']['usage'])) {
                                    $usage = $parsed['choices'][0]['delta']['usage'];
                                    echo "data: " . json_encode([
                                        'usage' => $usage,
                                        'modelId' => $modelId,
                                        'threadId' => $thread->getThreadId(),
                                        'promptId' => $promptId
                                    ], JSON_UNESCAPED_UNICODE) . "\n\n";
                                    flush();
                                }
                            } catch (\Exception $e) {
                                error_log('Error parsing streaming response: ' . $e->getMessage());
                                // Send error message to client
                                echo "data: " . json_encode([
                                    'error' => 'Error processing response',
                                    'modelId' => $modelId
                                ], JSON_UNESCAPED_UNICODE) . "\n\n";
                                flush();
                            }
                        }
                    }
                }
    
                // If we get here without a [DONE] message, save what we have
                if (!$historySaved && !empty($content)) {
                    $chatHistory = new ChatHistory();
                    $chatHistory->setThread($thread)
                        ->setPrompt($prompt)
                        ->setPromptId($promptId)
                        ->setResponse([
                            'content' => $content,
                            'usage' => [
                                'prompt_tokens' => 0,
                                'completion_tokens' => 0,
                                'total_tokens' => 0
                            ]
                        ])
                        ->setModelId($modelId)
                        ->setOpenRouterId($openRouterId);
                    
                    $em->persist($chatHistory);
                    $em->flush();
                }
            });
            
            $response->headers->set('Content-Type', 'text/event-stream');
            $response->headers->set('Cache-Control', 'no-cache');
            $response->headers->set('Connection', 'keep-alive');
            $response->headers->set('X-Accel-Buffering', 'no');
            
            return $response;
        } else {
            // Non-streaming response
            $responses = [];
            
            // Save initial user prompt only once
            $userPromptHistory = new ChatHistory();
            $userPromptHistory->setThread($thread) // Using the same thread for all
                ->setPrompt($prompt)
                ->setPromptId($promptId)
                ->setResponse([
                    'content' => '',
                    'usage' => [
                        'prompt_tokens' => 0,
                        'completion_tokens' => 0,
                        'total_tokens' => 0
                    ]
                ])
                ->setModelId('user_prompt')
                ->setCreatedAt(new \DateTime());
            $em->persist($userPromptHistory);
            
            // Process all models but use the same thread
            foreach ($models as $modelId) {
                $modelResponses = $openRouter->generateResponse($prompt, [$modelId]);
                
                if (!isset($modelResponses[$modelId])) {
                    continue;
                }
                
                $modelResponse = $modelResponses[$modelId];
                
                // Create a ChatHistory entry for this model but with the same thread
                $modelHistory = new ChatHistory();
                $modelHistory->setThread($thread) // Using the same thread
                    ->setPrompt($prompt)
                    ->setPromptId($promptId)
                    ->setResponse([
                        'content' => $modelResponse['content'],
                        'usage' => $modelResponse['usage'] ?? [
                            'prompt_tokens' => 0,
                            'completion_tokens' => 0,
                            'total_tokens' => 0
                        ]
                    ])
                    ->setModelId($modelId)
                    ->setOpenRouterId($modelResponse['id']);
                
                $em->persist($modelHistory);
                
                $responses[$modelId] = [
                    'content' => $modelResponse['content'],
                    'usage' => $modelResponse['usage'] ?? [
                        'prompt_tokens' => 0,
                        'completion_tokens' => 0,
                        'total_tokens' => 0
                    ]
                ];
            }
            
            // Flush once after all entities are prepared
            $em->flush();
            
            return $this->json([
                'responses' => $responses,
                'threadId' => $thread->getThreadId(), // Return the same thread ID for all
                'promptId' => $promptId,
                'usage' => [
                    'user' => $user->getThreads()->count(),
                    'organization' => $organization->getUsageCount()
                ]
            ]);
        }
    }

    
    #[Route('/chat/history', methods: ['GET'])]
    public function history(): JsonResponse
    {
        $user = $this->getUser();
        $threads = $user->getThreads();
        $data = [];
        
        foreach ($threads as $thread) {
            $histories = $thread->getChatHistories()->toArray();
            
            // Sort histories by creation date, oldest first
            usort($histories, function($a, $b) {
                return $a->getCreatedAt() <=> $b->getCreatedAt();
            });
            
            if (!empty($histories)) {
                $messages = [];
                $currentPromptId = null;
                $currentPromptResponses = [];
                
                foreach ($histories as $history) {
                    if ($currentPromptId !== $history->getPromptId()) {
                        // If we have responses from previous prompt, add them
                        if (!empty($currentPromptResponses)) {
                            $messages[] = [
                                'prompt' => $currentPromptResponses[0]['prompt'],
                                'responses' => array_column($currentPromptResponses, 'response', 'modelId'),
                                'createdAt' => $currentPromptResponses[0]['createdAt'],
                                'promptId' => $currentPromptId
                            ];
                        }
                        
                        // Start new group
                        $currentPromptId = $history->getPromptId();
                        $currentPromptResponses = [];
                    }
                    
                    $currentPromptResponses[] = [
                        'prompt' => $history->getPrompt(),
                        'response' => $history->getResponse(),
                        'modelId' => $history->getModelId(),
                        'createdAt' => $history->getCreatedAt()->format('Y-m-d H:i:s')
                    ];
                }
                
                // Don't forget to add the last group
                if (!empty($currentPromptResponses)) {
                    $messages[] = [
                        'prompt' => $currentPromptResponses[0]['prompt'],
                        'responses' => array_column($currentPromptResponses, 'response', 'modelId'),
                        'createdAt' => $currentPromptResponses[0]['createdAt'],
                        'promptId' => $currentPromptId
                    ];
                }
                
                $data[] = [
                    'id' => $thread->getId(),
                    'title' => $messages[0]['prompt'], // Use first message as title
                    'messages' => $messages,
                    'threadId' => $thread->getThreadId(),
                    'createdAt' => $thread->getCreatedAt()->format('Y-m-d H:i:s')
                ];
            }
        }
        
        // Sort by creation date, newest first
        usort($data, function($a, $b) {
            return strtotime($b['createdAt']) - strtotime($a['createdAt']);
        });
        
        return $this->json($data);
    }

    #[Route('/chat/thread/{threadId}', methods: ['GET'])]
    public function getThread(string $threadId, EntityManagerInterface $em): JsonResponse
    {
        $user = $this->getUser();
        $thread = $em->getRepository(Thread::class)
            ->findOneBy(['threadId' => $threadId, 'user' => $user]);
            
        if (!$thread) {
            throw $this->createNotFoundException('Thread not found');
        }
        
        $messages = [];
        $histories = $thread->getChatHistories()->toArray();
        
        // Sort histories by creation date, oldest first
        usort($histories, function($a, $b) {
            return $a->getCreatedAt() <=> $b->getCreatedAt();
        });
        
        $currentPromptId = null;
        $currentPromptResponses = [];
        
        foreach ($histories as $history) {
            if ($currentPromptId !== $history->getPromptId()) {
                // If we have responses from previous prompt, add them
                if (!empty($currentPromptResponses)) {
                    $messages[] = [
                        'prompt' => $currentPromptResponses[0]['prompt'],
                        'responses' => array_column($currentPromptResponses, 'response', 'modelId'),
                        'createdAt' => $currentPromptResponses[0]['createdAt'],
                        'promptId' => $currentPromptId
                    ];
                }
                
                // Start new group
                $currentPromptId = $history->getPromptId();
                $currentPromptResponses = [];
            }
            
            $currentPromptResponses[] = [
                'prompt' => $history->getPrompt(),
                'response' => $history->getResponse(),
                'modelId' => $history->getModelId(),
                'createdAt' => $history->getCreatedAt()->format('Y-m-d H:i:s')
            ];
        }
        
        // Don't forget to add the last group
        if (!empty($currentPromptResponses)) {
            $messages[] = [
                'prompt' => $currentPromptResponses[0]['prompt'],
                'responses' => array_column($currentPromptResponses, 'response', 'modelId'),
                'createdAt' => $currentPromptResponses[0]['createdAt'],
                'promptId' => $currentPromptId
            ];
        }
        
        return $this->json([
            'messages' => $messages,
            'threadId' => $thread->getThreadId()
        ]);
    }

    #[Route('/chat/thread', methods: ['POST'])]
    public function createThread(EntityManagerInterface $em): JsonResponse
    {
        $user = $this->getUser();
        
        $thread = new Thread();
        $thread->setTitle('New Chat');
        $thread->setUser($user);
        $thread->setThreadId(uniqid('thread_', true));
        
        $em->persist($thread);
        $em->flush();
        
        return $this->json([
            'threadId' => $thread->getThreadId()
        ]);
    }

    #[Route('/chat/costs', methods: ['GET'])]
    public function getCosts(EntityManagerInterface $em): JsonResponse
    {
        $user = $this->getUser();
        
        $qb = $em->createQueryBuilder();
        $qb->select('t.threadId', 't.title', 't.createdAt as threadCreatedAt', 'COUNT(ch.id) as messageCount')
           ->from(Thread::class, 't')
           ->leftJoin('t.chatHistories', 'ch')
           ->where('t.user = :user')
           ->setParameter('user', $user)
           ->groupBy('t.threadId', 't.title', 't.createdAt')
           ->orderBy('t.createdAt', 'DESC');
        
        $threads = $qb->getQuery()->getResult();
        
        // Get costs for each thread
        $threadCosts = [];
        foreach ($threads as $thread) {
            // Get total costs and tokens for this thread
            $stats = $em->createQueryBuilder()
                ->select('COALESCE(SUM(cc.totalCost), 0) as totalCost')
                ->addSelect('COALESCE(SUM(cc.tokensPrompt), 0) as totalPromptTokens')
                ->addSelect('COALESCE(SUM(cc.tokensCompletion), 0) as totalCompletionTokens')
                ->from('App\Entity\ChatCost', 'cc')
                ->join('cc.chatHistory', 'ch')
                ->join('ch.thread', 't')
                ->where('t.threadId = :threadId')
                ->setParameter('threadId', $thread['threadId'])
                ->getQuery()
                ->getSingleResult();
                
            $threadCosts[] = [
                'threadId' => $thread['threadId'],
                'title' => $thread['title'],
                'messageCount' => (int)$thread['messageCount'],
                'lastMessageDate' => $thread['threadCreatedAt']->format('Y-m-d H:i:s'),
                'totalCost' => (float)$stats['totalCost'],
                'totalTokens' => (int)($stats['totalPromptTokens'] + $stats['totalCompletionTokens'])
            ];
        }
        
        return $this->json($threadCosts);
    }
}

================
File: backend/src/Controller/SecurityController.php
================
<?php

namespace App\Controller;

use App\Repository\UserRepository;
use App\Service\JWTService;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class SecurityController extends AbstractController
{
    #[Route('/login', name: 'app_login')]
    public function login()
    {
        return $this->redirectToRoute('connect_google');
    }

    #[Route('/logout', name: 'app_logout')]
    public function logout()
    {
        // This method can be empty - it will be intercepted by the logout key on your firewall
    }
    
    #[Route('/api/token/refresh', name: 'api_token_refresh', methods: ['POST'])]
    public function refreshToken(Request $request, JWTService $jwtService, UserRepository $userRepository): JsonResponse
    {
        // Extract token from Authorization header
        $authHeader = $request->headers->get('Authorization');
        
        if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {
            return new JsonResponse(['error' => 'missing_auth_header', 'message' => 'Missing or invalid Authorization header'], Response::HTTP_UNAUTHORIZED);
        }
        
        $token = str_replace('Bearer ', '', $authHeader);
        
        try {
            // Try to decode the token without validation to extract user info
            $tokenParts = explode('.', $token);
            if (count($tokenParts) !== 3) {
                return new JsonResponse(['error' => 'invalid_token_format', 'message' => 'Invalid token format'], Response::HTTP_UNAUTHORIZED);
            }
            
            $payloadBase64 = $tokenParts[1];
            $payloadJson = base64_decode(str_replace(['-', '_'], ['+', '/'], $payloadBase64));
            $payload = json_decode($payloadJson, true);
            
            if (!isset($payload['sub'])) {
                return new JsonResponse(['error' => 'invalid_payload', 'message' => 'Invalid token payload: missing sub claim'], Response::HTTP_UNAUTHORIZED);
            }
            
            // Find user by ID
            $user = $userRepository->find($payload['sub']);
            
            if (!$user) {
                // Try to find by googleId as fallback
                $user = $userRepository->findOneBy(['googleId' => $payload['googleId'] ?? '']);
                
                if (!$user) {
                    return new JsonResponse([
                        'error' => 'user_not_found', 
                        'message' => 'User not found with ID: ' . $payload['sub']
                    ], Response::HTTP_UNAUTHORIZED);
                }
            }
            
            try {
                // Create a new token
                $newToken = $jwtService->createToken($user);
                
                return new JsonResponse([
                    'token' => $newToken,
                    'expires_in' => 3600 * 24 * 7 // 7 days in seconds
                ]);
            } catch (\Exception $tokenError) {
                return new JsonResponse([
                    'error' => 'token_creation_failed',
                    'message' => 'Failed to create token: ' . $tokenError->getMessage()
                ], Response::HTTP_INTERNAL_SERVER_ERROR);
            }
            
        } catch (\Exception $e) {
            return new JsonResponse([
                'error' => 'token_refresh_failed',
                'message' => 'Token refresh failed: ' . $e->getMessage()
            ], Response::HTTP_UNAUTHORIZED);
        }
    }
}

================
File: backend/src/Entity/ChatCost.php
================
<?php

namespace App\Entity;

use DateTime;
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class ChatCost
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\ManyToOne(targetEntity: ChatHistory::class)]
    #[ORM\JoinColumn(nullable: false)]
    private ChatHistory $chatHistory;

    #[ORM\Column(type: "float")]
    private float $totalCost;

    #[ORM\Column(type: "datetime")]
    private DateTime $createdAt;

    #[ORM\Column(type: "string")]
    private string $openRouterId;

    #[ORM\Column(type: "string")]
    private string $model;

    #[ORM\Column(type: "string", nullable: true)]
    private ?string $origin = null;

    #[ORM\Column(type: "float", nullable: true)]
    private ?float $totalUsage = null;

    #[ORM\Column(type: "boolean")]
    private bool $isByok = false;

    #[ORM\Column(type: "string", nullable: true)]
    private ?string $upstreamId = null;

    #[ORM\Column(type: "float", nullable: true)]
    private ?float $cacheDiscount = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $appId = null;

    #[ORM\Column(type: "boolean")]
    private bool $streamed = false;

    #[ORM\Column(type: "boolean")]
    private bool $cancelled = false;

    #[ORM\Column(type: "string", nullable: true)]
    private ?string $providerName = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $latency = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $moderationLatency = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $generationTime = null;

    #[ORM\Column(type: "string", nullable: true)]
    private ?string $finishReason = null;

    #[ORM\Column(type: "string", nullable: true)]
    private ?string $nativeFinishReason = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $tokensPrompt = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $tokensCompletion = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $nativeTokensPrompt = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $nativeTokensCompletion = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $nativeTokensReasoning = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $numMediaPrompt = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $numMediaCompletion = null;

    #[ORM\Column(type: "integer", nullable: true)]
    private ?int $numSearchResults = null;

    public function __construct()
    {
        $this->createdAt = new DateTime();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getChatHistory(): ChatHistory
    {
        return $this->chatHistory;
    }

    public function setChatHistory(ChatHistory $chatHistory): self
    {
        $this->chatHistory = $chatHistory;
        return $this;
    }

    public function getTotalCost(): float
    {
        return $this->totalCost;
    }

    public function setTotalCost(float $totalCost): self
    {
        $this->totalCost = $totalCost;
        return $this;
    }

    public function getCreatedAt(): DateTime
    {
        return $this->createdAt;
    }

    public function setCreatedAt(DateTime $createdAt): self
    {
        $this->createdAt = $createdAt;
        return $this;
    }

    public function getOpenRouterId(): string
    {
        return $this->openRouterId;
    }

    public function setOpenRouterId(string $openRouterId): self
    {
        $this->openRouterId = $openRouterId;
        return $this;
    }

    public function getModel(): string
    {
        return $this->model;
    }

    public function setModel(string $model): self
    {
        $this->model = $model;
        return $this;
    }

    public function getOrigin(): ?string
    {
        return $this->origin;
    }

    public function setOrigin(?string $origin): self
    {
        $this->origin = $origin;
        return $this;
    }

    public function getTotalUsage(): ?float
    {
        return $this->totalUsage;
    }

    public function setTotalUsage(?float $totalUsage): self
    {
        $this->totalUsage = $totalUsage;
        return $this;
    }

    public function getIsByok(): bool
    {
        return $this->isByok;
    }

    public function setIsByok(bool $isByok): self
    {
        $this->isByok = $isByok;
        return $this;
    }

    public function getUpstreamId(): ?string
    {
        return $this->upstreamId;
    }

    public function setUpstreamId(?string $upstreamId): self
    {
        $this->upstreamId = $upstreamId;
        return $this;
    }

    public function getCacheDiscount(): ?float
    {
        return $this->cacheDiscount;
    }

    public function setCacheDiscount(?float $cacheDiscount): self
    {
        $this->cacheDiscount = $cacheDiscount;
        return $this;
    }

    public function getAppId(): ?int
    {
        return $this->appId;
    }

    public function setAppId(?int $appId): self
    {
        $this->appId = $appId;
        return $this;
    }

    public function getStreamed(): bool
    {
        return $this->streamed;
    }

    public function setStreamed(bool $streamed): self
    {
        $this->streamed = $streamed;
        return $this;
    }

    public function getCancelled(): bool
    {
        return $this->cancelled;
    }

    public function setCancelled(bool $cancelled): self
    {
        $this->cancelled = $cancelled;
        return $this;
    }

    public function getProviderName(): ?string
    {
        return $this->providerName;
    }

    public function setProviderName(?string $providerName): self
    {
        $this->providerName = $providerName;
        return $this;
    }

    public function getLatency(): ?int
    {
        return $this->latency;
    }

    public function setLatency(?int $latency): self
    {
        $this->latency = $latency;
        return $this;
    }

    public function getModerationLatency(): ?int
    {
        return $this->moderationLatency;
    }

    public function setModerationLatency(?int $moderationLatency): self
    {
        $this->moderationLatency = $moderationLatency;
        return $this;
    }

    public function getGenerationTime(): ?int
    {
        return $this->generationTime;
    }

    public function setGenerationTime(?int $generationTime): self
    {
        $this->generationTime = $generationTime;
        return $this;
    }

    public function getFinishReason(): ?string
    {
        return $this->finishReason;
    }

    public function setFinishReason(?string $finishReason): self
    {
        $this->finishReason = $finishReason;
        return $this;
    }

    public function getNativeFinishReason(): ?string
    {
        return $this->nativeFinishReason;
    }

    public function setNativeFinishReason(?string $nativeFinishReason): self
    {
        $this->nativeFinishReason = $nativeFinishReason;
        return $this;
    }

    public function getTokensPrompt(): ?int
    {
        return $this->tokensPrompt;
    }

    public function setTokensPrompt(?int $tokensPrompt): self
    {
        $this->tokensPrompt = $tokensPrompt;
        return $this;
    }

    public function getTokensCompletion(): ?int
    {
        return $this->tokensCompletion;
    }

    public function setTokensCompletion(?int $tokensCompletion): self
    {
        $this->tokensCompletion = $tokensCompletion;
        return $this;
    }

    public function getNativeTokensPrompt(): ?int
    {
        return $this->nativeTokensPrompt;
    }

    public function setNativeTokensPrompt(?int $nativeTokensPrompt): self
    {
        $this->nativeTokensPrompt = $nativeTokensPrompt;
        return $this;
    }

    public function getNativeTokensCompletion(): ?int
    {
        return $this->nativeTokensCompletion;
    }

    public function setNativeTokensCompletion(?int $nativeTokensCompletion): self
    {
        $this->nativeTokensCompletion = $nativeTokensCompletion;
        return $this;
    }

    public function getNativeTokensReasoning(): ?int
    {
        return $this->nativeTokensReasoning;
    }

    public function setNativeTokensReasoning(?int $nativeTokensReasoning): self
    {
        $this->nativeTokensReasoning = $nativeTokensReasoning;
        return $this;
    }

    public function getNumMediaPrompt(): ?int
    {
        return $this->numMediaPrompt;
    }

    public function setNumMediaPrompt(?int $numMediaPrompt): self
    {
        $this->numMediaPrompt = $numMediaPrompt;
        return $this;
    }

    public function getNumMediaCompletion(): ?int
    {
        return $this->numMediaCompletion;
    }

    public function setNumMediaCompletion(?int $numMediaCompletion): self
    {
        $this->numMediaCompletion = $numMediaCompletion;
        return $this;
    }

    public function getNumSearchResults(): ?int
    {
        return $this->numSearchResults;
    }

    public function setNumSearchResults(?int $numSearchResults): self
    {
        $this->numSearchResults = $numSearchResults;
        return $this;
    }
}

================
File: backend/src/Entity/ChatHistory.php
================
<?php

namespace App\Entity;

use DateTime;
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class ChatHistory
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;
    
    #[ORM\ManyToOne(targetEntity: Thread::class, inversedBy: "chatHistories")]
    #[ORM\JoinColumn(nullable: false)]
    private Thread $thread;
    
    #[ORM\Column(type: "text")]
    private string $prompt;
    
    #[ORM\Column(type: "string")]
    private string $promptId;
    
    #[ORM\Column(type: "json")]
    private array $response;
    
    #[ORM\Column(type: "string")]
    private string $modelId;
    
    #[ORM\Column(type: "string", nullable: true)]
    private ?string $openRouterId = null;
    
    #[ORM\Column(type: "datetime")]
    private DateTime $createdAt;

    public function __construct()
    {
        $this->createdAt = new DateTime();
        $this->promptId = uniqid('prompt_');
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getThread(): Thread
    {
        return $this->thread;
    }

    public function setThread(Thread $thread): self
    {
        $this->thread = $thread;
        return $this;
    }

    public function getPrompt(): string
    {
        return $this->prompt;
    }

    public function setPrompt(string $prompt): self
    {
        $this->prompt = $prompt;
        return $this;
    }

    public function getPromptId(): string
    {
        return $this->promptId;
    }

    public function setPromptId(string $promptId): self
    {
        $this->promptId = $promptId;
        return $this;
    }

    public function getResponse(): array
    {
        return $this->response;
    }

    public function setResponse(array $response): self
    {
        $this->response = $response;
        return $this;
    }

    public function getModelId(): string
    {
        return $this->modelId;
    }

    public function setModelId(string $modelId): self
    {
        $this->modelId = $modelId;
        return $this;
    }

    public function getOpenRouterId(): ?string
    {
        return $this->openRouterId;
    }

    public function setOpenRouterId(?string $openRouterId): self
    {
        $this->openRouterId = $openRouterId;
        return $this;
    }

    public function getCreatedAt(): DateTime
    {
        return $this->createdAt;
    }

    public function setCreatedAt(DateTime $createdAt): self
    {
        $this->createdAt = $createdAt;
        return $this;
    }
}

================
File: backend/src/Entity/Organization.php
================
<?php

namespace App\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Serializer\Annotation\Groups;

#[ORM\Entity]
class Organization
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    #[Groups(['organization:read'])]
    private ?int $id = null;
    
    #[ORM\Column(length: 255)]
    #[Groups(['organization:read'])]
    private string $googleId;
    
    #[ORM\Column(length: 255, nullable: true)]
    #[Groups(['organization:read'])]
    private ?string $domain = null;
    
    #[ORM\Column(type: "integer")]
    #[Groups(['organization:read'])]
    private int $usageCount = 0;
    
    #[ORM\ManyToOne(targetEntity: User::class)]
    #[Groups(['organization:read'])]
    private ?User $user = null;

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getGoogleId(): string
    {
        return $this->googleId;
    }

    public function setGoogleId(string $googleId): self
    {
        $this->googleId = $googleId;

        return $this;
    }
    
    public function getDomain(): ?string
    {
        return $this->domain;
    }

    public function setDomain(?string $domain): self
    {
        $this->domain = $domain;

        return $this;
    }
    
    public function getUsageCount(): int
    {
        return $this->usageCount;
    }

    public function setUsageCount(int $usageCount): self
    {
        $this->usageCount = $usageCount;

        return $this;
    }

    public function getUser(): ?User
    {
        return $this->user;
    }

    public function setUser(?User $user): self
    {
        $this->user = $user;

        return $this;
    }
}

================
File: backend/src/Entity/Thread.php
================
<?php

namespace App\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class Thread
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(type: "string", length: 255)]
    private string $title;

    #[ORM\ManyToOne(targetEntity: User::class, inversedBy: "threads")]
    #[ORM\JoinColumn(nullable: false)]
    private User $user;

    #[ORM\Column(type: "datetime")]
    private \DateTime $createdAt;

    #[ORM\Column(type: "string", unique: true)]
    private string $threadId;

    #[ORM\OneToMany(targetEntity: ChatHistory::class, mappedBy: "thread", cascade: ["persist", "remove"])]
    private Collection $chatHistories;

    public function __construct()
    {
        $this->chatHistories = new ArrayCollection();
        $this->createdAt = new \DateTime();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getTitle(): string
    {
        return $this->title;
    }

    public function setTitle(string $title): self
    {
        $this->title = $title;
        return $this;
    }

    public function getUser(): User
    {
        return $this->user;
    }

    public function setUser(User $user): self
    {
        $this->user = $user;
        return $this;
    }

    public function getCreatedAt(): \DateTime
    {
        return $this->createdAt;
    }

    public function setCreatedAt(\DateTime $createdAt): self
    {
        $this->createdAt = $createdAt;
        return $this;
    }

    public function getThreadId(): string
    {
        return $this->threadId;
    }

    public function setThreadId(string $threadId): self
    {
        $this->threadId = $threadId;
        return $this;
    }

    public function getChatHistories(): Collection
    {
        return $this->chatHistories;
    }

    public function addChatHistory(ChatHistory $chatHistory): self
    {
        if (!$this->chatHistories->contains($chatHistory)) {
            $this->chatHistories->add($chatHistory);
            $chatHistory->setThread($this);
        }
        return $this;
    }

    public function removeChatHistory(ChatHistory $chatHistory): self
    {
        if ($this->chatHistories->removeElement($chatHistory)) {
            if ($chatHistory->getThread() === $this) {
                $chatHistory->setThread(null);
            }
        }
        return $this;
    }
}

================
File: backend/src/Entity/User.php
================
<?php

namespace App\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Serializer\Annotation\Groups;

#[ORM\Entity]
class User implements UserInterface, PasswordAuthenticatedUserInterface
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    #[Groups(['user:read'])]
    private ?int $id = null;

    #[ORM\Column(length: 255, unique: true)]
    #[Groups(['user:read'])]
    private string $googleId;

    #[ORM\Column]
    #[Groups(['user:read'])]
    private array $roles = [];

    #[ORM\Column(length: 255)]
    #[Groups(['user:read'])]
    private ?string $email = null;

    #[ORM\ManyToOne(targetEntity: Organization::class)]
    #[ORM\JoinColumn(nullable: true)]
    #[Groups(['user:read'])]
    private ?Organization $organization = null;

    #[ORM\OneToMany(targetEntity: Thread::class, mappedBy: "user", cascade: ["persist", "remove"])]
    private Collection $threads;

    public function __construct()
    {
        $this->threads = new ArrayCollection();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getGoogleId(): string
    {
        return $this->googleId;
    }

    public function setGoogleId(string $googleId): self
    {
        $this->googleId = $googleId;

        return $this;
    }
    
    public function getOrganization(): ?Organization
    {
        return $this->organization;
    }

    public function setOrganization(?Organization $organization): self
    {
        $this->organization = $organization;

        return $this;
    }

    public function getThreads(): Collection
    {
        return $this->threads;
    }

    public function addThread(Thread $thread): self
    {
        if (!$this->threads->contains($thread)) {
            $this->threads->add($thread);
            $thread->setUser($this);
        }

        return $this;
    }

    public function removeThread(Thread $thread): self
    {
        if ($this->threads->removeElement($thread)) {
            // set the owning side to null (unless already changed)
            if ($thread->getUser() === $this) {
                $thread->setUser(null);
            }
        }

        return $this;
    }

    public function getRoles(): array
    {
        return ['ROLE_USER'];
    }

    public function getPassword(): ?string
    {
        return null;
    }

    public function getSalt(): ?string
    {
        return null;
    }

    public function eraseCredentials(): void
    {
        // If you store any temporary, sensitive data on the user, clear it here
        // $this->plainPassword = null;
    }

     /**
     * Returns the identifier for this user (e.g. its email address).
     *
     * @return string
     */
    public function getUserIdentifier(): string
    {
        return $this->googleId;
    }
    
     /**
     * @see UserInterface
     */
    public function getUsername(): string
    {
        return $this->getUserIdentifier();
    }

    public function getEmail(): ?string
    {
        return $this->email;
    }

    public function setEmail(?string $email): void
    {
        $this->email = $email;
    }

    public function setRoles(array $roles): void
    {
        $this->roles = $roles;
    }
}

================
File: backend/src/Repository/OrganizationRepository.php
================
<?php

namespace App\Repository;

use App\Entity\Organization;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<Organization>
 */
class OrganizationRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Organization::class);
    }

    public function save(Organization $entity, bool $flush = false): void
    {
        $this->getEntityManager()->persist($entity);

        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }

    public function remove(Organization $entity, bool $flush = false): void
    {
        $this->getEntityManager()->remove($entity);

        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }
}

================
File: backend/src/Repository/UserRepository.php
================
<?php

namespace App\Repository;

use App\Entity\User;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

class UserRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, User::class);
    }
}

================
File: backend/src/Security/GoogleAuthenticator.php
================
<?php

namespace App\Security;

use App\Entity\Organization;
use App\Entity\User;
use App\Repository\OrganizationRepository;
use App\Repository\UserRepository;
use Doctrine\ORM\EntityManagerInterface;
use KnpU\OAuth2ClientBundle\Client\ClientRegistry;
use KnpU\OAuth2ClientBundle\Security\Authenticator\OAuth2Authenticator;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\RouterInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;

class GoogleAuthenticator extends OAuth2Authenticator
{

    public function __construct(
        private ClientRegistry $clientRegistry,
        private RouterInterface $router,
        private UserRepository $userRepository,
        private OrganizationRepository $organizationRepository,
        private EntityManagerInterface $entityManager,
    ) {
    }

    public function supports(Request $request): ?bool
    {
        return $request->attributes->get('_route') === 'connect_google_check';
    }

    public function authenticate(Request $request): Passport
    {
        $client = $this->clientRegistry->getClient('google');
        $accessToken = $this->fetchAccessToken($client);

        return new SelfValidatingPassport(
            new UserBadge($accessToken->getToken(), function() use ($accessToken, $client) {
                /** @var \League\OAuth2\Client\Provider\GoogleUser $googleUser */
                $googleUser = $client->fetchUserFromToken($accessToken);

                $email = $googleUser->getEmail();
                $googleId = $googleUser->getId();

                // 1) have they logged in with Google before?
                $existingUser = $this->userRepository->findOneBy(['googleId' => $googleId]);

                if ($existingUser) {
                    return $existingUser;
                }

                // 2) do we have a matching user by email?
                $user = $this->userRepository->findOneBy(['email' => $email]);

                // 3) create new user if doesn't exist
                if (!$user) {
                    $user = new User();
                    $user->setEmail($email);
                    $user->setGoogleId($googleId);
                    $user->setRoles(['ROLE_USER']);

                    // Check if email is from a Google Workspace domain
                    $domain = substr(strrchr($email, "@"), 1);
                    if ($domain && $domain !== 'gmail.com') {
                        // Check if organization exists for this domain
                        $organization = $this->organizationRepository->findOneBy(['domain' => $domain]);

                        if (!$organization) {
                            // Create new organization
                            $organization = new Organization();
                            $organization->setGoogleId($domain);
                            $organization->setDomain($domain);
                            $organization->setUsageCount(0);
                            $this->entityManager->persist($organization);
                        }

                        $user->setOrganization($organization);
                    }

                    $this->entityManager->persist($user);
                    $this->entityManager->flush();
                }

                return $user;
            })
        );
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        // Let the controller handle the redirect with token
        return null;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
    {
        // Redirect to frontend with error
        return new RedirectResponse(
            ($_ENV['FRONTEND_URL'] ?? 'http://localhost:5173') . '/callback?error=' . urlencode($exception->getMessage())
        );
    }
}

================
File: backend/src/Security/JWTAuthenticator.php
================
<?php

namespace App\Security;

use App\Repository\UserRepository;
use App\Service\JWTService;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;

class JWTAuthenticator extends AbstractAuthenticator
{

    public function __construct(private JWTService $jwtService, private UserRepository $userRepository)
    {
    }

    public function supports(Request $request): ?bool
    {
        return $request->headers->has('Authorization') 
            && str_starts_with($request->headers->get('Authorization'), 'Bearer ');
    }

    public function authenticate(Request $request): Passport
    {
        $authHeader = $request->headers->get('Authorization');
        
        if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {
            throw new AuthenticationException('Missing or invalid Authorization header');
        }
        
        $token = str_replace('Bearer ', '', $authHeader);

        try {
            $payload = $this->jwtService->validateToken($token);
    
            if (!$payload) {
                // Check if token is expired by trying to decode it without verification
                try {
                    // This is a simple check to see if the token structure is valid
                    $tokenParts = explode('.', $token);
                    if (count($tokenParts) === 3) {
                        $payloadBase64 = $tokenParts[1];
                        $payloadJson = base64_decode(str_replace(['-', '_'], ['+', '/'], $payloadBase64));
                        $payloadData = json_decode($payloadJson, true);
                        
                        if (isset($payloadData['exp']) && $payloadData['exp'] < time()) {
                            throw new AuthenticationException('JWT token has expired');
                        }
                    }
                } catch (\Exception $e) {
                    // Ignore any errors in this basic check
                }
                
                // If we couldn't determine a specific reason, use a generic message
                throw new AuthenticationException('Invalid JWT token');
            }
    
            if (!isset($payload['sub'])) {
                throw new AuthenticationException('JWT token missing subject claim');
            }
            
            return new SelfValidatingPassport(
                new UserBadge($payload['sub'], function ($userIdentifier) use ($payload) {
                    // Try to find by ID first (for existing tokens)
                    $user = $this->userRepository->find($userIdentifier);
                    
                    // If not found and we have a googleId in the payload, try that
                    if (!$user && isset($payload['googleId'])) {
                        $user = $this->userRepository->findOneBy(['googleId' => $payload['googleId']]);
                    }
                    
                    if (!$user) {
                        throw new AuthenticationException('User not found for token');
                    }
                    
                    return $user;
                })
            );
        } catch (\Exception $e) {
            // Log the error for debugging
            error_log('JWT Authentication failed: ' . $e->getMessage());
            throw new AuthenticationException('Authentication failed: ' . $e->getMessage());
        }
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        // Continue with the request
        return null;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
    {
        return new JsonResponse(['message' => 'Authentication failed: ' . $exception->getMessage()], Response::HTTP_UNAUTHORIZED);
    }
}

================
File: backend/src/Service/JWTService.php
================
<?php

namespace App\Service;

use App\Entity\User;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;

class JWTService
{
    private JWTTokenManagerInterface $jwtManager;
    private int $tokenLifetime;

    public function __construct(
        JWTTokenManagerInterface $jwtManager,
        int $tokenLifetime = 3600 * 24 * 7 // 7 days by default
    ) {
        $this->jwtManager = $jwtManager;
        $this->tokenLifetime = $tokenLifetime;
    }

    public function createToken(User $user): string
    {
        try {
            // Set custom payload claims
            $payload = [
                'sub' => $user->getId(),
                'email' => $user->getEmail(),
                'googleId' => $user->getGoogleId(),
                'exp' => time() + $this->tokenLifetime // Add expiration time
            ];
            
            // Ensure all required fields are present
            if (!$user->getId()) {
                throw new \InvalidArgumentException('User ID is missing');
            }
            
            if (!$user->getEmail()) {
                throw new \InvalidArgumentException('User email is missing');
            }
            
            if (!$user->getGoogleId()) {
                throw new \InvalidArgumentException('User googleId is missing');
            }
            
            return $this->jwtManager->createFromPayload($user, $payload);
        } catch (\Exception $e) {
            // Log the error for debugging
            error_log('JWT Token creation failed: ' . $e->getMessage());
            throw $e; // Re-throw to be handled by the caller
        }
    }

    public function validateToken(string $token): ?array
    {
        try {
            $payload = $this->jwtManager->parse($token);
            
            // Check if token has expired
            if (isset($payload['exp']) && $payload['exp'] < time()) {
                // Token has expired
                return null;
            }
            
            return $payload;
        } catch (\Exception $e) {
            // Log the error or handle specific JWT exceptions
            // You could add a logger here to track token validation failures
            return null;
        }
    }
}

================
File: backend/src/Service/ModelService.php
================
<?php

namespace App\Service;

use Symfony\Component\Cache\Adapter\AdapterInterface;
use Symfony\Contracts\Cache\ItemInterface;

class ModelService
{
    private OpenRouterService $openRouterService;
    private AdapterInterface $cache;
    private int $cacheTtl;
    
    public function __construct(
        OpenRouterService $openRouterService,
        AdapterInterface $cache,
        int $cacheTtl = 3600 // Default 1 hour cache
    ) {
        $this->openRouterService = $openRouterService;
        $this->cache = $cache;
        $this->cacheTtl = $cacheTtl;
    }
    
    public function getModels(): array
    {
        return $this->cache->get('openrouter_models', function (ItemInterface $item) {
            $item->expiresAfter($this->cacheTtl);
            
            $rawModels = $this->openRouterService->getModels();
            return $this->formatModels($rawModels);
        });
    }
    
    public function refreshModels(): array
    {
        $this->cache->delete('openrouter_models');
        return $this->getModels();
    }
    
    private function formatModels(array $rawModels): array
    {
        if (empty($rawModels)) {
            return [];
        }

        $formattedModels = [];
        
        foreach ($rawModels as $model) {
            if (!isset($model['id'])) {
                continue;
            }

            $formattedModels[] = [
                'id' => $model['id'],
                'name' => $model['name'] ?? $model['id'],
                'description' => $model['description'] ?? null,
                'provider' => $this->extractProviderFromId($model['id']),
                'selected' => false,
                'pricing' => [
                    'prompt' => $model['pricing']['prompt'] ?? null,
                    'completion' => $model['pricing']['completion'] ?? null,
                    'unit' => 'tokens'
                ]
            ];
        }
        
        return $formattedModels;
    }
    
    private function extractProviderFromId(string $id): ?string
    {
        // Extract provider from model ID (e.g., "anthropic/claude-3-opus" -> "anthropic")
        if (strpos($id, '/') !== false) {
            return explode('/', $id)[0];
        }
        
        return null;
    }
}

================
File: backend/src/Service/OpenRouterService.php
================
<?php

namespace App\Service;

use Symfony\Contracts\HttpClient\HttpClientInterface;
use Symfony\Component\HttpKernel\Exception\HttpException;

class OpenRouterService
{
    private HttpClientInterface $client;
    private string $apiKey;
    private const API_URL = 'https://openrouter.ai/api/v1';
    
    public function __construct(HttpClientInterface $client, string $apiKey)
    {
        $this->client = $client;
        $this->apiKey = $apiKey;
    }
    
    public function getModels(): array
    {
        try {
            $response = $this->client->request('GET', self::API_URL . '/models');
            
            if ($response->getStatusCode() !== 200) {
                throw new HttpException($response->getStatusCode(), 'Failed to fetch models from OpenRouter');
            }
            
            $data = $response->toArray();
            error_log('OpenRouter API Response: ' . json_encode($data));
            return $data['data'] ?? [];
        } catch (\Exception $e) {
            error_log('OpenRouter API Error: ' . $e->getMessage());
            throw new HttpException(500, 'Failed to fetch models: ' . $e->getMessage());
        }
    }

    public function getGenerationData(string $generationId): array
    {
        try {
            $response = $this->client->request('GET', self::API_URL . '/generation', [
                'headers' => [
                    'Authorization' => "Bearer {$this->apiKey}",
                    'X-Title' => 'AI MultiChat',
                    'Content-Type' => 'application/json'
                ],
                'query' => [
                    'id' => $generationId
                ]
            ]);

            if ($response->getStatusCode() !== 200) {
                throw new HttpException($response->getStatusCode(), 'Failed to fetch generation data from OpenRouter');
            }

            $data = $response->toArray();
            return $data['data'] ?? [];
        } catch (\Exception $e) {
            error_log('OpenRouter API Error: ' . $e->getMessage());
            throw new HttpException(500, 'Failed to fetch generation data: ' . $e->getMessage());
        }
    }
    
    public function generateResponse(string $prompt, array $models, bool $stream = false): array
    {
        $responses = [];
        foreach ($models as $model) {
            try {
                $response = $this->client->request('POST', self::API_URL . '/chat/completions', [
                    'headers' => [
                        'Authorization' => "Bearer {$this->apiKey}",
                        'X-Title' => 'AI MultiChat',
                        'Content-Type' => 'application/json'
                    ],
                    'json' => [
                        'model' => $model,
                        'messages' => [
                            [
                                'role' => 'user',
                                'content' => $prompt
                            ]
                        ],
                        'stream' => $stream
                    ]
                ]);
                
                if ($response->getStatusCode() !== 200) {
                    $errorData = $response->toArray();
                    throw new HttpException(
                        $response->getStatusCode(),
                        $errorData['error']['message'] ?? 'Failed to generate response from OpenRouter'
                    );
                }
                
                if ($stream) {
                    $responses[$model] = [
                        'stream' => $response->toStream(),
                        'id' => null,
                        'usage' => [
                            'prompt_tokens' => 0,
                            'completion_tokens' => 0,
                            'total_tokens' => 0
                        ]
                    ];
                } else {
                    $data = $response->toArray();
                    if (!isset($data['choices'][0]['message']['content'])) {
                        throw new HttpException(500, 'Invalid response format from OpenRouter');
                    }
                    
                    $responses[$model] = [
                        'content' => $data['choices'][0]['message']['content'],
                        'id' => $data['id'] ?? null,
                        'usage' => [
                            'prompt_tokens' => $data['usage']['prompt_tokens'] ?? 0,
                            'completion_tokens' => $data['usage']['completion_tokens'] ?? 0,
                            'total_tokens' => $data['usage']['total_tokens'] ?? 0
                        ]
                    ];
                }
            } catch (\Exception $e) {
                $responses[$model] = [
                    'content' => 'Error: ' . $e->getMessage(),
                    'id' => null,
                    'usage' => [
                        'prompt_tokens' => 0,
                        'completion_tokens' => 0,
                        'total_tokens' => 0
                    ]
                ];
            }
        }
        return $responses;
    }

    public function streamResponse(string $prompt, array $models): array
    {
        $responses = [];
        foreach ($models as $model) {
            try {
                $response = $this->client->request('POST', self::API_URL . '/chat/completions', [
                    'headers' => [
                        'Authorization' => "Bearer {$this->apiKey}",
                        'X-Title' => 'AI MultiChat',
                        'Content-Type' => 'application/json'
                    ],
                    'json' => [
                        'model' => $model,
                        'messages' => [
                            [
                                'role' => 'user',
                                'content' => $prompt
                            ]
                        ],
                        'stream' => true
                    ]
                ]);
                
                if ($response->getStatusCode() !== 200) {
                    $errorData = $response->toArray();
                    throw new HttpException(
                        $response->getStatusCode(),
                        $errorData['error']['message'] ?? 'Failed to generate response from OpenRouter'
                    );
                }
                
                $responses[$model] = [
                    'stream' => $response->toStream(),
                    'id' => null,
                    'usage' => [
                        'prompt_tokens' => 0,
                        'completion_tokens' => 0,
                        'total_tokens' => 0
                    ]
                ];
            } catch (\Exception $e) {
                $responses[$model] = [
                    'content' => 'Error: ' . $e->getMessage(),
                    'id' => null,
                    'usage' => [
                        'prompt_tokens' => 0,
                        'completion_tokens' => 0,
                        'total_tokens' => 0
                    ]
                ];
            }
        }
        return $responses;
    }
}

================
File: backend/src/Kernel.php
================
<?php

namespace App;

use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
use Symfony\Component\HttpKernel\Kernel as BaseKernel;

class Kernel extends BaseKernel
{
    use MicroKernelTrait;
}

================
File: backend/templates/home/index.html.twig
================
{% extends 'base.html.twig' %}

{% block title %}Home{% endblock %}

{% block body %}
    <h1>Welcome</h1>
    {% if app.user %}
        <p>Hello {{ app.user.email }}!</p>
        <a href="{{ path('app_logout') }}">Logout</a>
    {% else %}
        <a href="{{ path('app_login') }}">Login with Google</a>
    {% endif %}
{% endblock %}

================
File: backend/templates/base.html.twig
================
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>{% block title %}Welcome!{% endblock %}</title>
        <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 128 128%22><text y=%221.2em%22 font-size=%2296%22>⚫️</text><text y=%221.3em%22 x=%220.2em%22 font-size=%2276%22 fill=%22%23fff%22>sf</text></svg>">
        {% block stylesheets %}
        {% endblock %}

        {% block javascripts %}
            {% block importmap %}{{ importmap('app') }}{% endblock %}
        {% endblock %}
    </head>
    <body>
        {% block body %}{% endblock %}
    </body>
</html>

================
File: backend/tests/bootstrap.php
================
<?php

use Symfony\Component\Dotenv\Dotenv;

require dirname(__DIR__).'/vendor/autoload.php';

if (method_exists(Dotenv::class, 'bootEnv')) {
    (new Dotenv())->bootEnv(dirname(__DIR__).'/.env');
}

================
File: backend/.dockerignore
================
# Git
.git
.gitignore

# Docker
Dockerfile
docker-compose.yml
docker-compose.*.yml

# Symfony
/var/
/vendor/
/.env.local
/.env.*.local

# PHPUnit
/phpunit.xml
/.phpunit.result.cache

# Composer
/composer.phar

# IDE files
/.idea/
/.vscode/

# OS specific files
.DS_Store
Thumbs.db

================
File: backend/.env.dev
================
###> symfony/framework-bundle ###
APP_SECRET=001ee91d220b0ec171985d8aae22b7bc
###< symfony/framework-bundle ###

###> nelmio/cors-bundle ###
# Allow frontend origin for CORS
CORS_ALLOW_ORIGIN='^https?://(localhost|127\.0\.0\.1)(:[0-9]+)?$'
###< nelmio/cors-bundle ###

###> lexik/jwt-authentication-bundle ###
JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem
JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem
JWT_PASSPHRASE=your_passphrase_here
###< lexik/jwt-authentication-bundle ###

================
File: backend/.env.test
================
# define your env variables for the test env here
KERNEL_CLASS='App\Kernel'
APP_SECRET='$ecretf0rt3st'
SYMFONY_DEPRECATIONS_HELPER=999999
PANTHER_APP_ENV=panther
PANTHER_ERROR_SCREENSHOT_DIR=./var/error-screenshots

================
File: backend/.gitignore
================
###> symfony/framework-bundle ###
/.env.local
/.env.local.php
/.env.*.local
/config/secrets/prod/prod.decrypt.private.php
/public/bundles/
/var/
/vendor/
###< symfony/framework-bundle ###

###> phpunit/phpunit ###
/phpunit.xml
.phpunit.result.cache
###< phpunit/phpunit ###

###> symfony/phpunit-bridge ###
.phpunit.result.cache
/phpunit.xml
###< symfony/phpunit-bridge ###

###> symfony/asset-mapper ###
/public/assets/
/assets/vendor/
###< symfony/asset-mapper ###

###> lexik/jwt-authentication-bundle ###
/config/jwt/*.pem
###< lexik/jwt-authentication-bundle ###

================
File: backend/compose.override.yaml
================
services:
###> doctrine/doctrine-bundle ###
  database:
    ports:
      - "3306:3306"
###< doctrine/doctrine-bundle ###

###> symfony/mailer ###
  mailer:
    image: axllent/mailpit
    ports:
      - "1025"
      - "8025"
    environment:
      MP_SMTP_AUTH_ACCEPT_ANY: 1
      MP_SMTP_AUTH_ALLOW_INSECURE: 1
###< symfony/mailer ###

================
File: backend/compose.yaml
================
services:
###> doctrine/doctrine-bundle ###
  database:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: ${MYSQL_DATABASE:-app}
      # You should definitely change the password in production
      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-!ChangeMe!}
      MYSQL_USER: ${MYSQL_USER:-app}
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-!ChangeMe!}
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${MYSQL_ROOT_PASSWORD:-!ChangeMe!}"]
      timeout: 5s
      retries: 5
      start_period: 60s
    volumes:
      - database_data:/var/lib/mysql:rw
      # You may use a bind-mounted host directory instead, so that it is harder to accidentally remove the volume and lose all your data!
      # - ./docker/db/data:/var/lib/mysql:rw
###< doctrine/doctrine-bundle ###

volumes:
###> doctrine/doctrine-bundle ###
  database_data:
###< doctrine/doctrine-bundle ###

================
File: backend/composer.json
================
{
    "type": "project",
    "license": "proprietary",
    "minimum-stability": "stable",
    "prefer-stable": true,
    "require": {
        "php": ">=8.2",
        "ext-ctype": "*",
        "ext-iconv": "*",
        "doctrine/dbal": "^3",
        "doctrine/doctrine-bundle": "^2.14",
        "doctrine/doctrine-migrations-bundle": "^3.4",
        "doctrine/orm": "^3.3",
        "guzzlehttp/guzzle": "^7.9",
        "knpuniversity/oauth2-client-bundle": "^2.18",
        "league/oauth2-google": "^4.0",
        "lexik/jwt-authentication-bundle": "^3.1",
        "nelmio/cors-bundle": "*",
        "phpdocumentor/reflection-docblock": "^5.6",
        "phpstan/phpdoc-parser": "^2.1",
        "symfony/asset": "7.2.*",
        "symfony/asset-mapper": "7.2.*",
        "symfony/console": "7.2.*",
        "symfony/doctrine-messenger": "7.2.*",
        "symfony/dotenv": "7.2.*",
        "symfony/expression-language": "7.2.*",
        "symfony/flex": "^2",
        "symfony/form": "7.2.*",
        "symfony/framework-bundle": "7.2.*",
        "symfony/http-client": "7.2.*",
        "symfony/intl": "7.2.*",
        "symfony/mailer": "7.2.*",
        "symfony/mime": "7.2.*",
        "symfony/monolog-bundle": "^3.0",
        "symfony/notifier": "7.2.*",
        "symfony/process": "7.2.*",
        "symfony/property-access": "7.2.*",
        "symfony/property-info": "7.2.*",
        "symfony/runtime": "7.2.*",
        "symfony/security-bundle": "7.2.*",
        "symfony/serializer": "7.2.*",
        "symfony/stimulus-bundle": "^2.23",
        "symfony/string": "7.2.*",
        "symfony/translation": "7.2.*",
        "symfony/twig-bundle": "7.2.*",
        "symfony/ux-turbo": "^2.23",
        "symfony/validator": "7.2.*",
        "symfony/web-link": "7.2.*",
        "symfony/yaml": "7.2.*",
        "twig/extra-bundle": "^2.12|^3.0",
        "twig/twig": "^2.12|^3.0"
    },
    "config": {
        "allow-plugins": {
            "php-http/discovery": true,
            "symfony/flex": true,
            "symfony/runtime": true
        },
        "bump-after-update": true,
        "sort-packages": true
    },
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "App\\Tests\\": "tests/"
        }
    },
    "replace": {
        "symfony/polyfill-ctype": "*",
        "symfony/polyfill-iconv": "*",
        "symfony/polyfill-php72": "*",
        "symfony/polyfill-php73": "*",
        "symfony/polyfill-php74": "*",
        "symfony/polyfill-php80": "*",
        "symfony/polyfill-php81": "*",
        "symfony/polyfill-php82": "*"
    },
    "scripts": {
        "auto-scripts": {
            "cache:clear": "symfony-cmd",
            "assets:install %PUBLIC_DIR%": "symfony-cmd",
            "importmap:install": "symfony-cmd"
        },
        "post-install-cmd": [
            "@auto-scripts"
        ],
        "post-update-cmd": [
            "@auto-scripts"
        ]
    },
    "conflict": {
        "symfony/symfony": "*"
    },
    "extra": {
        "symfony": {
            "allow-contrib": false,
            "require": "7.2.*"
        }
    },
    "require-dev": {
        "phpunit/phpunit": "^9.5",
        "symfony/browser-kit": "7.2.*",
        "symfony/css-selector": "7.2.*",
        "symfony/debug-bundle": "7.2.*",
        "symfony/maker-bundle": "^1.0",
        "symfony/phpunit-bridge": "^7.2",
        "symfony/stopwatch": "7.2.*",
        "symfony/web-profiler-bundle": "7.2.*"
    }
}

================
File: backend/Dockerfile
================
FROM php:8.2-fpm

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    unzip \
    libzip-dev \
    libicu-dev \
    libonig-dev \
    libxml2-dev \
    && docker-php-ext-install \
    pdo_mysql \
    zip \
    intl \
    opcache \
    mbstring \
    exif \
    pcntl \
    bcmath \
    xml

# Install Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Set working directory
WORKDIR /var/www/html

# Copy composer files and install dependencies
COPY composer.json composer.lock ./
RUN composer install --no-scripts --no-autoloader

# Copy application files
COPY . .

# Generate optimized autoloader
RUN composer dump-autoload --optimize

# Create var directory and set permissions
RUN mkdir -p /var/www/html/var && \
    chown -R www-data:www-data /var/www/html/var

# Expose port 9000 for PHP-FPM
EXPOSE 9000

CMD ["php-fpm"]

================
File: backend/Dockerfile.prod
================
FROM php:8.2-fpm AS php_base

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    unzip \
    libzip-dev \
    libicu-dev \
    libonig-dev \
    libxml2-dev \
    && docker-php-ext-install \
    pdo_mysql \
    zip \
    intl \
    opcache \
    mbstring \
    exif \
    pcntl \
    bcmath \
    xml

# Install Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Configure PHP for production
RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" \
    && echo "opcache.memory_consumption=256" >> "$PHP_INI_DIR/php.ini" \
    && echo "opcache.max_accelerated_files=20000" >> "$PHP_INI_DIR/php.ini" \
    && echo "opcache.validate_timestamps=0" >> "$PHP_INI_DIR/php.ini" \
    && echo "realpath_cache_size=4096K" >> "$PHP_INI_DIR/php.ini" \
    && echo "realpath_cache_ttl=600" >> "$PHP_INI_DIR/php.ini"

# Set working directory
WORKDIR /var/www/html

# Build stage for dependencies and application
FROM php_base AS build

# Copy composer files
COPY composer.json composer.lock ./

# Install dependencies
RUN composer install --no-dev --optimize-autoloader --no-scripts

# Copy application files
COPY . .

# Run Symfony cache clear and warmup
RUN APP_ENV=prod APP_DEBUG=0 php bin/console cache:clear --no-warmup \
    && APP_ENV=prod APP_DEBUG=0 php bin/console cache:warmup

# Final stage
FROM php_base

# Copy application from build stage
COPY --from=build /var/www/html /var/www/html

# Create var directory and set permissions
RUN mkdir -p /var/www/html/var && \
    chown -R www-data:www-data /var/www/html/var

# Expose port 9000 for PHP-FPM
EXPOSE 9000

CMD ["php-fpm"]

================
File: backend/importmap.php
================
<?php

/**
 * Returns the importmap for this application.
 *
 * - "path" is a path inside the asset mapper system. Use the
 *     "debug:asset-map" command to see the full list of paths.
 *
 * - "entrypoint" (JavaScript only) set to true for any module that will
 *     be used as an "entrypoint" (and passed to the importmap() Twig function).
 *
 * The "importmap:require" command can be used to add new entries to this file.
 */
return [
    'app' => [
        'path' => './assets/app.js',
        'entrypoint' => true,
    ],
    '@hotwired/stimulus' => [
        'version' => '3.2.2',
    ],
    '@symfony/stimulus-bundle' => [
        'path' => './vendor/symfony/stimulus-bundle/assets/dist/loader.js',
    ],
    '@hotwired/turbo' => [
        'version' => '7.3.0',
    ],
    'axios' => [
        'version' => '1.8.4',
    ],
];

================
File: backend/php.ini
================
max_execution_time = 120
max_input_time = 120
memory_limit = 256M

================
File: backend/phpunit.xml.dist
================
<?xml version="1.0" encoding="UTF-8"?>

<!-- https://phpunit.readthedocs.io/en/latest/configuration.html -->
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="tests/bootstrap.php"
         convertDeprecationsToExceptions="false"
>
    <php>
        <ini name="display_errors" value="1" />
        <ini name="error_reporting" value="-1" />
        <server name="APP_ENV" value="test" force="true" />
        <server name="SHELL_VERBOSITY" value="-1" />
        <server name="SYMFONY_PHPUNIT_REMOVE" value="" />
        <server name="SYMFONY_PHPUNIT_VERSION" value="9.5" />
    </php>

    <testsuites>
        <testsuite name="Project Test Suite">
            <directory>tests</directory>
        </testsuite>
    </testsuites>

    <coverage processUncoveredFiles="true">
        <include>
            <directory suffix=".php">src</directory>
        </include>
    </coverage>

    <listeners>
        <listener class="Symfony\Bridge\PhpUnit\SymfonyTestsListener" />
    </listeners>

    <extensions>
    </extensions>
</phpunit>

================
File: backend/symfony.lock
================
{
    "doctrine/doctrine-bundle": {
        "version": "2.14",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "2.13",
            "ref": "8d96c0b51591ffc26794d865ba3ee7d193438a83"
        },
        "files": [
            "config/packages/doctrine.yaml",
            "src/Entity/.gitignore",
            "src/Repository/.gitignore"
        ]
    },
    "doctrine/doctrine-migrations-bundle": {
        "version": "3.4",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "3.1",
            "ref": "1d01ec03c6ecbd67c3375c5478c9a423ae5d6a33"
        },
        "files": [
            "config/packages/doctrine_migrations.yaml",
            "migrations/.gitignore"
        ]
    },
    "knpuniversity/oauth2-client-bundle": {
        "version": "2.18",
        "recipe": {
            "repo": "github.com/symfony/recipes-contrib",
            "branch": "main",
            "version": "1.20",
            "ref": "1ff300d8c030f55c99219cc55050b97a695af3f6"
        },
        "files": [
            "config/packages/knpu_oauth2_client.yaml"
        ]
    },
    "lexik/jwt-authentication-bundle": {
        "version": "3.1",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "2.5",
            "ref": "e9481b233a11ef7e15fe055a2b21fd3ac1aa2bb7"
        },
        "files": [
            "config/packages/lexik_jwt_authentication.yaml"
        ]
    },
    "nelmio/cors-bundle": {
        "version": "2.5",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "1.5",
            "ref": "6bea22e6c564fba3a1391615cada1437d0bde39c"
        },
        "files": [
            "config/packages/nelmio_cors.yaml"
        ]
    },
    "phpunit/phpunit": {
        "version": "9.6",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "9.6",
            "ref": "6a9341aa97d441627f8bd424ae85dc04c944f8b4"
        },
        "files": [
            ".env.test",
            "phpunit.xml.dist",
            "tests/bootstrap.php"
        ]
    },
    "symfony/asset-mapper": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "6.4",
            "ref": "5ad1308aa756d58f999ffbe1540d1189f5d7d14a"
        },
        "files": [
            "assets/app.js",
            "assets/styles/app.css",
            "config/packages/asset_mapper.yaml",
            "importmap.php"
        ]
    },
    "symfony/console": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "5.3",
            "ref": "1781ff40d8a17d87cf53f8d4cf0c8346ed2bb461"
        },
        "files": [
            "bin/console"
        ]
    },
    "symfony/debug-bundle": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "5.3",
            "ref": "5aa8aa48234c8eb6dbdd7b3cd5d791485d2cec4b"
        },
        "files": [
            "config/packages/debug.yaml"
        ]
    },
    "symfony/flex": {
        "version": "2.5",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "2.4",
            "ref": "52e9754527a15e2b79d9a610f98185a1fe46622a"
        },
        "files": [
            ".env",
            ".env.dev"
        ]
    },
    "symfony/form": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "7.2",
            "ref": "7d86a6723f4a623f59e2bf966b6aad2fc461d36b"
        },
        "files": [
            "config/packages/csrf.yaml"
        ]
    },
    "symfony/framework-bundle": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "7.2",
            "ref": "87bcf6f7c55201f345d8895deda46d2adbdbaa89"
        },
        "files": [
            "config/packages/cache.yaml",
            "config/packages/framework.yaml",
            "config/preload.php",
            "config/routes/framework.yaml",
            "config/services.yaml",
            "public/index.php",
            "src/Controller/.gitignore",
            "src/Kernel.php"
        ]
    },
    "symfony/mailer": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "4.3",
            "ref": "09051cfde49476e3c12cd3a0e44289ace1c75a4f"
        },
        "files": [
            "config/packages/mailer.yaml"
        ]
    },
    "symfony/maker-bundle": {
        "version": "1.62",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "1.0",
            "ref": "fadbfe33303a76e25cb63401050439aa9b1a9c7f"
        }
    },
    "symfony/messenger": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "6.0",
            "ref": "ba1ac4e919baba5644d31b57a3284d6ba12d52ee"
        },
        "files": [
            "config/packages/messenger.yaml"
        ]
    },
    "symfony/monolog-bundle": {
        "version": "3.10",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "3.7",
            "ref": "aff23899c4440dd995907613c1dd709b6f59503f"
        },
        "files": [
            "config/packages/monolog.yaml"
        ]
    },
    "symfony/notifier": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "5.0",
            "ref": "178877daf79d2dbd62129dd03612cb1a2cb407cc"
        },
        "files": [
            "config/packages/notifier.yaml"
        ]
    },
    "symfony/phpunit-bridge": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "6.3",
            "ref": "a411a0480041243d97382cac7984f7dce7813c08"
        },
        "files": [
            ".env.test",
            "bin/phpunit",
            "phpunit.xml.dist",
            "tests/bootstrap.php"
        ]
    },
    "symfony/routing": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "7.0",
            "ref": "21b72649d5622d8f7da329ffb5afb232a023619d"
        },
        "files": [
            "config/packages/routing.yaml",
            "config/routes.yaml"
        ]
    },
    "symfony/security-bundle": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "6.4",
            "ref": "2ae08430db28c8eb4476605894296c82a642028f"
        },
        "files": [
            "config/packages/security.yaml",
            "config/routes/security.yaml"
        ]
    },
    "symfony/stimulus-bundle": {
        "version": "2.23",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "2.20",
            "ref": "3acc494b566816514a6873a89023a35440b6386d"
        },
        "files": [
            "assets/bootstrap.js",
            "assets/controllers.json",
            "assets/controllers/csrf_protection_controller.js",
            "assets/controllers/hello_controller.js"
        ]
    },
    "symfony/translation": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "6.3",
            "ref": "e28e27f53663cc34f0be2837aba18e3a1bef8e7b"
        },
        "files": [
            "config/packages/translation.yaml",
            "translations/.gitignore"
        ]
    },
    "symfony/twig-bundle": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "6.4",
            "ref": "cab5fd2a13a45c266d45a7d9337e28dee6272877"
        },
        "files": [
            "config/packages/twig.yaml",
            "templates/base.html.twig"
        ]
    },
    "symfony/ux-turbo": {
        "version": "2.23",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "2.20",
            "ref": "c85ff94da66841d7ff087c19cbcd97a2df744ef9"
        }
    },
    "symfony/validator": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "7.0",
            "ref": "8c1c4e28d26a124b0bb273f537ca8ce443472bfd"
        },
        "files": [
            "config/packages/validator.yaml"
        ]
    },
    "symfony/web-profiler-bundle": {
        "version": "7.2",
        "recipe": {
            "repo": "github.com/symfony/recipes",
            "branch": "main",
            "version": "6.1",
            "ref": "8b51135b84f4266e3b4c8a6dc23c9d1e32e543b7"
        },
        "files": [
            "config/packages/web_profiler.yaml",
            "config/routes/web_profiler.yaml"
        ]
    },
    "twig/extra-bundle": {
        "version": "v3.20.0"
    }
}

================
File: backend/test-jwt.php
================
<?php

require __DIR__ . '/vendor/autoload.php';

use App\Entity\User;
use App\Service\JWTService;
use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\HttpKernel\KernelInterface;
use Symfony\Component\Dotenv\Dotenv;

// Load environment variables
(new Dotenv())->bootEnv(__DIR__ . '/.env');

// Create a minimal kernel to get the container
$kernel = new class('dev', true) extends Kernel {
    public function registerBundles(): iterable
    {
        $contents = require $this->getProjectDir() . '/config/bundles.php';
        foreach ($contents as $class => $envs) {
            if ($envs[$this->environment] ?? $envs['all'] ?? false) {
                yield new $class();
            }
        }
    }

    public function getProjectDir(): string
    {
        return __DIR__;
    }
    
    public function registerContainerConfiguration(\Symfony\Component\Config\Loader\LoaderInterface $loader): void
    {
        $loader->load($this->getProjectDir().'/config/packages/*.yaml', 'glob');
        $loader->load($this->getProjectDir().'/config/{packages}/'.$this->environment.'/*.yaml', 'glob');
        $loader->load($this->getProjectDir().'/config/{services}.yaml', 'glob');
        $loader->load($this->getProjectDir().'/config/{services}_'.$this->environment.'.yaml', 'glob');
    }
};

$kernel->boot();
$container = $kernel->getContainer();

// Get the user repository and JWT service
$userRepository = $container->get('doctrine')->getRepository(User::class);
$jwtService = $container->get(JWTService::class);

// Find the first user
$user = $userRepository->findOneBy([]);

if (!$user) {
    echo "No user found in the database.\n";
    exit(1);
}

// Generate a JWT token
$token = $jwtService->createToken($user);

echo "JWT Token for user {$user->getEmail()}:\n";
echo $token . "\n\n";

// Test the API endpoint
echo "Testing API endpoint with the token...\n";
$ch = curl_init('http://localhost:8000/api/models');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, [
    'Authorization: Bearer ' . $token,
    'Content-Type: application/json'
]);
$response = curl_exec($ch);
$httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
curl_close($ch);

echo "HTTP Status Code: $httpCode\n";
echo "Response:\n";
echo $response . "\n";

================
File: docker/nginx/backend.conf
================
server {
    listen 80;
    server_name localhost;
    root /var/www/html/public;

    location / {
        try_files $uri /index.php$is_args$args;
    }

    location ~ ^/index\.php(/|$) {
        fastcgi_pass php:9000;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param DOCUMENT_ROOT $document_root;
        internal;
    }

    location ~ \.php$ {
        return 404;
    }

    error_log /var/log/nginx/project_error.log;
    access_log /var/log/nginx/project_access.log;
}

================
File: frontend/src/components/Callback.tsx
================
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';

const Callback: React.FC = () => {
    const navigate = useNavigate();
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');
        const errorParam = urlParams.get('error');

        if (errorParam) {
            setError(errorParam);
            setTimeout(() => navigate('/login'), 3000);
            return;
        }

        if (token) {
            // Store the token in localStorage
            localStorage.setItem('token', token);
            
            // Redirect to the main app
            navigate('/');
        } else {
            setError('No token found in callback');
            setTimeout(() => navigate('/login'), 3000);
        }
    }, [navigate]);

    if (error) {
        return (
            <div className="flex items-center justify-center min-h-screen bg-gray-100">
                <div className="p-8 bg-white rounded-lg shadow-md">
                    <p className="text-red-500">Error: {error}</p>
                    <p>Redirecting to login page...</p>
                </div>
            </div>
        );
    }

    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-100">
            <div className="p-8 bg-white rounded-lg shadow-md">
                <p className="text-lg">Processing login...</p>
                <div className="mt-4 w-full bg-gray-200 rounded-full h-2.5">
                    <div className="bg-blue-600 h-2.5 rounded-full w-3/4 animate-pulse"></div>
                </div>
            </div>
        </div>
    );
};

export default Callback;

================
File: frontend/src/components/CostsPage.tsx
================
import React, { useEffect, useState } from 'react';
import { getThreadCosts, ThreadCost } from '../services/api';

const CostsPage: React.FC = () => {
  const [threadCosts, setThreadCosts] = useState<ThreadCost[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchThreadCosts = async () => {
      try {
        setLoading(true);
        const data = await getThreadCosts();
        setThreadCosts(data);
      } catch (error) {
        console.error('Error fetching costs:', error);
        setError('Failed to load costs');
      } finally {
        setLoading(false);
      }
    };

    fetchThreadCosts();
  }, []);

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 4,
      maximumFractionDigits: 4
    }).format(amount);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-4rem)]">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-4rem)]">
        <div className="text-red-500">{error}</div>
      </div>
    );
  }

  if (threadCosts.length === 0) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-4rem)]">
        <div className="text-gray-500">No threads found</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6">Costs Overview</h1>
      <div className="grid gap-4">
        {threadCosts.map((thread) => (
          <div
            key={thread.threadId}
            className="bg-white rounded-lg shadow p-4 hover:shadow-md transition-shadow"
          >
            <div className="flex justify-between items-start mb-2">
              <div className="flex flex-col">
                <div className="text-sm font-medium text-gray-900">
                  {thread.title}
                </div>
                <div className="text-sm text-gray-500">
                  {thread.messageCount} messages
                </div>
                <div className="text-sm text-gray-500">
                  {new Date(thread.lastMessageDate).toLocaleString()}
                </div>
              </div>
              <div className="text-green-600 font-semibold">
                {formatCurrency(thread.totalCost)}
              </div>
            </div>
            <div className="text-sm text-gray-500">
              {thread.totalTokens.toLocaleString()} tokens
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default CostsPage;

================
File: frontend/src/components/Header.tsx
================
import { LogOut, DollarSign, MessageSquare } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';

export const Header = () => {
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = async () => {
    await logout();
    navigate('/login');
  };

  return (
    <header className="bg-white border-b border-gray-200">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          <div className="flex items-center">
            <MessageSquare className="h-8 w-8 text-blue-600" />
            <span className="ml-2 text-xl font-semibold text-gray-900">AI MultiChat</span>
          </div>

          <div className="flex items-center space-x-4">
            <button
              onClick={() => navigate('/costs')}
              className="p-2 rounded-full hover:bg-gray-100 transition-colors"
            >
              <DollarSign className="h-5 w-5 text-gray-600" />
            </button>
            
            <span className="text-gray-700">{user?.name}</span>
            
            <button
              onClick={handleLogout}
              className="p-2 rounded-full hover:bg-gray-100 transition-colors"
            >
              <LogOut className="h-5 w-5 text-gray-600" />
            </button>
          </div>
        </div>
      </div>
    </header>
  );
};

================
File: frontend/src/components/ChatHistory.tsx
================
import React, { useState, useEffect } from 'react';
import { MessageSquare, Plus, DollarSign } from 'lucide-react';
import { ChatSession } from '../types';
import { useNavigate } from 'react-router-dom';
import { getThreadCosts, ThreadCost } from '../services/api';

interface ChatHistoryProps {
  chatSessions: ChatSession[];
  onSelectChat: (sessionId: string) => void;
  onStartNewChat: () => void;
}

const ChatHistory: React.FC<ChatHistoryProps> = ({
  chatSessions,
  onSelectChat,
  onStartNewChat
}) => {
  const [activeTab, setActiveTab] = useState<'chats' | 'costs'>('chats');
  const [threadCosts, setThreadCosts] = useState<ThreadCost[]>([]);
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();

  const fetchThreadCosts = async () => {
    try {
      setLoading(true);
      const data = await getThreadCosts();
      setThreadCosts(data);
    } catch (error) {
      console.error('Error fetching costs:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (activeTab === 'costs') {
      fetchThreadCosts();
    }
  }, [activeTab]);

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount);
  };

  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <h2 className="text-lg font-semibold">Chat History</h2>
      </div>
      
      <div className="flex border-b">
        <button
          className={`flex-1 py-2 text-center ${
            activeTab === 'chats' ? 'border-b-2 border-blue-500 font-medium' : 'text-gray-500'
          }`}
          onClick={() => setActiveTab('chats')}
        >
          Chats
        </button>
        <button
          className={`flex-1 py-2 text-center ${
            activeTab === 'costs' ? 'border-b-2 border-blue-500 font-medium' : 'text-gray-500'
          }`}
          onClick={() => setActiveTab('costs')}
        >
          Costs
        </button>
      </div>
      
      <div className="flex-1 overflow-y-auto">
        {activeTab === 'chats' ? (
          chatSessions.length > 0 ? (
            <ul className="divide-y">
              {chatSessions.map((session) => (
                <li key={session.id}>
                  <button
                    className="w-full p-3 text-left hover:bg-gray-100 flex items-center"
                    onClick={() => onSelectChat(session.id)}
                  >
                    <MessageSquare size={18} className="mr-2 text-gray-500" />
                    <span className="truncate">{session.title}</span>
                  </button>
                </li>
              ))}
            </ul>
          ) : (
            <div className="p-4 text-center text-gray-500">No chat history</div>
          )
        ) : (
          loading ? (
            <div className="p-4 text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500 mx-auto"></div>
            </div>
          ) : threadCosts.length > 0 ? (
            <ul className="divide-y">
              {threadCosts.map((thread) => (
                <li key={thread.threadId}>
                  <div className="p-3 hover:bg-gray-100">
                    <div className="flex items-center justify-between mb-1">
                      <span className="font-medium truncate">{thread.title}</span>
                      <span className="text-green-600 font-semibold">
                        {formatCurrency(thread.totalCost)}
                      </span>
                    </div>
                    <div className="text-sm text-gray-500">
                      {thread.messageCount} messages • {new Date(thread.lastMessageDate).toLocaleDateString()}
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          ) : (
            <div className="p-4 text-center text-gray-500">No cost data available</div>
          )
        )}
      </div>
      
      {activeTab === 'chats' && (
        <div className="p-3 border-t">
          <button
            className="w-full py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 flex items-center justify-center"
            onClick={onStartNewChat}
          >
            <Plus size={18} className="mr-2" />
            New Chat
          </button>
        </div>
      )}
    </div>
  );
};

export default ChatHistory;

================
File: frontend/src/components/ChatInput.tsx
================
import React, { useState } from 'react';
import { Send } from 'lucide-react';
import { Message } from '../types';

interface ChatInputProps {
    onSendMessage: (message: string) => void;
    disabled: boolean;
    selectedModels: string[];
}

const ChatInput: React.FC<ChatInputProps> = ({ onSendMessage, disabled, selectedModels }) => {
    const [message, setMessage] = useState('');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (message.trim() && !disabled && !loading) {
            setLoading(true);
            try {
                onSendMessage(message);
                setMessage('');
            } catch (error) {
                console.error('Failed to send message:', error);
            } finally {
                setLoading(false);
            }
        }
    };

    return (
        <form onSubmit={handleSubmit} className="flex items-end gap-2">
            <div className="flex-1">
                <textarea
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    placeholder={disabled ? "Select at least one model to start chatting" : "Type your message here..."}
                    disabled={disabled || loading}
                    className={`w-full p-3 border rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent
                    ${disabled || loading ? 'bg-gray-100 text-gray-500' : 'bg-white'}`}
                    rows={3}
                    onKeyDown={(e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            handleSubmit(e);
                        }
                    }}
                />
            </div>
            <button
                type="submit"
                disabled={!message.trim() || disabled || loading}
                className={`p-3 rounded-lg ${
                    !message.trim() || disabled || loading
                        ? 'bg-gray-200 text-gray-500 cursor-not-allowed'
                        : 'bg-blue-600 text-white hover:bg-blue-700'
                }`}
            >
                <Send size={20} />
            </button>
        </form>
    );
};

export default ChatInput;

================
File: frontend/src/components/ChatMessage.tsx
================
import React from 'react';
import { Message } from '../types';
import { User, Bot, Activity } from 'lucide-react';

interface ChatMessageProps {
    message: Message;
    modelName?: string;
}

const ChatMessage: React.FC<ChatMessageProps> = ({ message, modelName }) => {
    const isUser = message.role === 'user';

    return (
        <div className={`flex gap-3 ${isUser ? 'justify-start' : 'justify-start'}`}>
            <div className={`w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0 ${
                isUser ? 'bg-blue-100 text-blue-600' : 'bg-purple-100 text-purple-600'
            }`}>
                {isUser ? <User size={18} /> : <Bot size={18} />}
            </div>

            <div className="flex-1">
                <div className="flex items-center justify-between mb-1">
                    <div className="font-medium text-sm text-gray-500">
                        {isUser ? 'You' : modelName || 'Assistant'}
                    </div>
                    {!isUser && message.usage && (
                        <div className="flex items-center text-xs text-gray-500">
                            <Activity size={14} className="mr-1" />
                            <span>
                                {message.usage.total_tokens} tokens
                                ({message.usage.prompt_tokens} prompt + {message.usage.completion_tokens} completion)
                            </span>
                        </div>
                    )}
                </div>
                <div className="text-gray-800 whitespace-pre-wrap">
                    {message.content}
                </div>
            </div>
        </div>
    );
};

export default ChatMessage;

================
File: frontend/src/components/ChatWindow.tsx
================
import React, { useEffect, useRef } from 'react';
import { Message, Model } from '../types';
import ChatMessage from './ChatMessage';
import ModelCheckbox from './ModelCheckbox';
import ChatInput from './ChatInput';

interface ChatWindowProps {
  messages: Message[];
  models: Model[];
  onModelToggle: (modelId: string) => void;
  onSendMessage: (messages: Message[], prompt: string) => void;
  isLoading?: boolean;
}

interface GroupedMessage {
  userMessage: Message;
  responses: Message[];
  timestamp: string;
}

const ChatWindow: React.FC<ChatWindowProps> = ({ messages = [], models = [], onModelToggle, onSendMessage, isLoading }) => {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const selectedModels = models.filter(model => model?.selected);

  // Auto scroll to bottom when messages change or streaming
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, isLoading]);

  // Group messages by prompt and timestamp
  const groupedMessages: GroupedMessage[] = [];
  
  if (messages?.length > 0) {
    let currentGroup: GroupedMessage | null = null;
    
    for (let i = 0; i < messages.length; i++) {
      const message = messages[i];
      
      if (!message) continue;
      
      if (message.role === 'user') {
        // If we have a previous group, add it to our list
        if (currentGroup) {
          groupedMessages.push(currentGroup);
        }
        
        // Start a new group with this user message
        currentGroup = {
          userMessage: message,
          responses: [],
          timestamp: new Date().toISOString()
        };
      } else if (message.role === 'assistant' && currentGroup) {
        // Add assistant message to current group
        currentGroup.responses.push(message);
      }
    }
    
    // Don't forget to add the last group
    if (currentGroup) {
      groupedMessages.push(currentGroup);
    }
  }

  return (
    <div className="flex-1 flex flex-col overflow-hidden">
      {/* Model selection bar */}
      {selectedModels.length > 0 && (
        <div className="bg-white border-b p-2 flex items-center overflow-x-auto">
          <div className="text-sm font-medium text-gray-500 mr-3">Active models:</div>
          <div className="flex space-x-2">
            {models.filter(model => model?.selected).map(model => (
              <ModelCheckbox
                key={model.id}
                model={model}
                onToggle={() => onModelToggle(model.id)}
              />
            ))}
          </div>
        </div>
      )}

      {/* Chat messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-8">
        {!messages?.length ? (
          <div className="h-full flex items-center justify-center text-gray-400 text-center p-8">
            <div>
              <p className="mb-2 text-lg">No messages yet</p>
              <p className="text-sm">Select models and start chatting to see responses</p>
            </div>
          </div>
        ) : (
          <>
            {groupedMessages.map((group, groupIndex) => (
              <div key={groupIndex} className="space-y-4">
                {/* User message */}
                <ChatMessage
                  message={group.userMessage}
                  modelName={undefined}
                />

                {/* Model responses in a grid layout */}
                {group.responses.length > 0 && (
                  <div className="mt-4">
                    <h3 className="text-sm font-medium text-gray-500 mb-2">Model Responses:</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {group.responses.map((response, responseIndex) => {
                        if (!response) return null;
                        const model = models.find(m => m?.id === response.modelId);
                        return (
                          <div
                            key={responseIndex}
                            className="border border-gray-200 rounded-lg overflow-hidden bg-white"
                          >
                            <div className="bg-gray-50 p-2 border-b border-gray-200">
                              <h4 className="font-medium text-sm text-gray-800">{model?.name || 'Unknown Model'}</h4>
                            </div>
                            <div className="p-3 text-sm whitespace-pre-wrap text-gray-800">
                              {typeof response.content === 'string' 
                                ? response.content 
                                : typeof response.content === 'object' && response.content !== null
                                  ? response.content.content || JSON.stringify(response.content)
                                  : JSON.stringify(response.content)}
                              {isLoading && responseIndex === group.responses.length - 1 && (
                                <span className="inline-block ml-1 animate-pulse">▊</span>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                )}
              </div>
            ))}
            <div ref={messagesEndRef} />
          </>
        )}
      </div>

      {/* Chat Input */}
      <div className="p-4 border-t">
        <ChatInput
          selectedModels={selectedModels.map(model => model.id)}
          onSendMessage={(message) => onSendMessage(messages, message)}
          disabled={selectedModels.length === 0 || isLoading}
        />
      </div>

      {/* Loading overlay */}
      {isLoading && (
        <div className="fixed bottom-20 right-4 bg-white rounded-lg shadow-lg p-3 flex items-center space-x-2">
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
          <span className="text-sm text-gray-600">Generating response...</span>
        </div>
      )}
    </div>
  );
};

export default ChatWindow;

================
File: frontend/src/components/Login.tsx
================
import React from 'react';

const Login: React.FC = () => {
    const backendUrl = import.meta.env.VITE_API_URL?.replace('/api', '') || 'http://localhost:8000';
    
    const handleGoogleLogin = () => {
        window.location.href = `${backendUrl}/connect/google`; // Symfony backend's Google OAuth login route
    };

    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-100">
            <div className="p-8 bg-white rounded-lg shadow-md w-96">
                <h2 className="text-2xl font-bold mb-6 text-center">Login to MultiChat</h2>
                <button 
                    onClick={handleGoogleLogin}
                    className="w-full py-2 px-4 bg-blue-600 text-white rounded-md hover:bg-blue-700 flex items-center justify-center"
                >
                    <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M12.545,10.239v3.821h5.445c-0.712,2.315-2.647,3.972-5.445,3.972c-3.332,0-6.033-2.701-6.033-6.032s2.701-6.032,6.033-6.032c1.498,0,2.866,0.549,3.921,1.453l2.814-2.814C17.503,2.988,15.139,2,12.545,2C7.021,2,2.543,6.477,2.543,12s4.478,10,10.002,10c8.396,0,10.249-7.85,9.426-11.748L12.545,10.239z"/>
                    </svg>
                    Login with Google
                </button>
            </div>
        </div>
    );
};

export default Login;

================
File: frontend/src/components/ModelCheckbox.tsx
================
import React from 'react';
import { Model } from '../types';
import { Check } from 'lucide-react';

interface ModelCheckboxProps {
    model: Model;
    onToggle: () => void;
}

const ModelCheckbox: React.FC<ModelCheckboxProps> = ({ model, onToggle }) => {
    return (
        <button
            onClick={onToggle}
            className={`
        flex items-center px-3 py-1 rounded-full text-sm transition-all
        ${model.selected
                ? 'bg-blue-100 text-blue-700 border border-blue-300'
                : 'bg-gray-100 text-gray-700 border border-gray-200'
            }
      `}
        >
            <span className="mr-1.5">{model.name}</span>
            <div className={`w-4 h-4 rounded-full flex items-center justify-center ${model.selected ? 'bg-blue-500' : 'border border-gray-300'}`}>
                {model.selected && <Check size={10} className="text-white" />}
            </div>
        </button>
    );
};

export default ModelCheckbox;

================
File: frontend/src/components/ModelSelector.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import { Model } from '../types';
import { Check, Info, RefreshCw, Search, X, HelpCircle } from 'lucide-react';
import { refreshModels } from '../services/api';

interface ModelSelectorProps {
    models: Model[];
    onModelToggle: (modelId: string) => void;
    maxModels: number;
}

const ModelSelector: React.FC<ModelSelectorProps> = ({ models, onModelToggle, maxModels }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [isOpen, setIsOpen] = useState(false);
    const [selectedCount, setSelectedCount] = useState(0);
    const dropdownRef = useRef<HTMLDivElement>(null);
    const [loading, setLoading] = useState(false);
    const [refreshing, setRefreshing] = useState(false);
    const hasActiveChat = models.some(model => model.selected);

    // Close dropdown when clicking outside
    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
                setIsOpen(false);
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    // Update selected count
    useEffect(() => {
        setSelectedCount(models.filter(m => m.selected).length);
    }, [models]);

    const filteredModels = models.filter(model =>
        model.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const formatPrice = (price: number) => {
        return `$${(price / 1000).toFixed(3)}/1k tokens`;
    };

    return (
        <div className="relative" ref={dropdownRef}>
            <div className="flex items-center justify-between mb-2">
                <h2 className="text-sm font-medium text-gray-700">Select Models</h2>
                <span className="text-xs text-gray-500">
                    {selectedCount}/{maxModels} models selected
                </span>
            </div>
            
            {/* Search input */}
            <div className="relative">
                <input
                    type="text"
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    onFocus={() => setIsOpen(true)}
                    placeholder="Search models..."
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
                <svg
                    className="absolute right-3 top-2.5 h-5 w-5 text-gray-400"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                >
                    <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                    />
                </svg>
            </div>

            {/* Dropdown */}
            {isOpen && (
                <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                    <div className="p-2">
                        {filteredModels.length === 0 ? (
                            <div className="text-sm text-gray-500 py-2 text-center">
                                No models found
                            </div>
                        ) : (
                            filteredModels.map(model => (
                                <button
                                    key={model.id}
                                    onClick={() => {
                                        onModelToggle(model.id);
                                        setSearchTerm('');
                                    }}
                                    disabled={!model.selected && selectedCount >= maxModels}
                                    className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors
                                        ${model.selected
                                            ? 'bg-blue-100 text-blue-800 hover:bg-blue-200'
                                            : 'text-gray-700 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed'
                                        }`}
                                >
                                    <div className="flex items-center justify-between">
                                        <span>{model.name}</span>
                                        {model.selected && (
                                            <svg
                                                className="h-4 w-4 text-blue-600"
                                                fill="none"
                                                stroke="currentColor"
                                                viewBox="0 0 24 24"
                                            >
                                                <path
                                                    strokeLinecap="round"
                                                    strokeLinejoin="round"
                                                    strokeWidth={2}
                                                    d="M5 13l4 4L19 7"
                                                />
                                            </svg>
                                        )}
                                    </div>
                                </button>
                            ))
                        )}
                    </div>
                </div>
            )}

            {/* Selected models chips */}
            <div className="mt-2 flex flex-wrap gap-2">
                {models
                    .filter(model => model.selected)
                    .map(model => (
                        <div
                            key={model.id}
                            className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-800"
                        >
                            {model.name}
                            <button
                                onClick={() => onModelToggle(model.id)}
                                className="ml-2 text-blue-600 hover:text-blue-800"
                            >
                                ×
                            </button>
                        </div>
                    ))}
            </div>
        </div>
    );
};

export default ModelSelector;

================
File: frontend/src/data/models.ts
================
import { Model } from '../types';

export const availableModels: Model[] = [
  {
    id: "anthropic/claude-3-opus",
    name: "Claude 3 Opus",
    description: "Anthropic's most powerful model for highly complex tasks",
    selected: false
  },
  {
    id: "anthropic/claude-3-sonnet",
    name: "Claude 3 Sonnet",
    description: "Balanced model for a wide range of tasks",
    selected: false
  },
  {
    id: "anthropic/claude-3-haiku",
    name: "Claude 3 Haiku",
    description: "Fast and efficient model for simpler tasks",
    selected: false
  },
  {
    id: "google/gemini-pro",
    name: "Gemini Pro",
    description: "Google's advanced reasoning and instruction model",
    selected: false
  },
  {
    id: "google/gemini-flash",
    name: "Gemini Flash",
    description: "Fast and efficient model from Google",
    selected: false
  },
  {
    id: "meta-llama/llama-3-70b-instruct",
    name: "Llama 3 70B",
    description: "Meta's largest open model with strong reasoning",
    selected: false
  },
  {
    id: "meta-llama/llama-3-8b-instruct",
    name: "Llama 3 8B",
    description: "Smaller, efficient Llama 3 model",
    selected: false
  },
  {
    id: "mistralai/mistral-large",
    name: "Mistral Large",
    description: "Mistral's most capable model",
    selected: false
  },
  {
    id: "mistralai/mistral-medium",
    name: "Mistral Medium",
    description: "Balanced performance and efficiency",
    selected: false
  },
  {
    id: "mistralai/mistral-small",
    name: "Mistral Small",
    description: "Fast and efficient model from Mistral",
    selected: false
  },
  {
    id: "openai/gpt-4o",
    name: "GPT-4o",
    description: "OpenAI's most advanced model",
    selected: false
  },
  {
    id: "openai/gpt-4-turbo",
    name: "GPT-4 Turbo",
    description: "Powerful model with strong reasoning capabilities",
    selected: false
  },
  {
    id: "openai/gpt-3.5-turbo",
    name: "GPT-3.5 Turbo",
    description: "Fast and cost-effective model",
    selected: false
  },
  {
    id: "cohere/command-r",
    name: "Command R",
    description: "Cohere's advanced reasoning model",
    selected: false
  },
  {
    id: "cohere/command-r-plus",
    name: "Command R+",
    description: "Enhanced version of Command R",
    selected: false
  },
  {
    id: "anthropic/claude-2",
    name: "Claude 2",
    description: "Previous generation Claude model",
    selected: false
  }
];

================
File: frontend/src/hooks/useAuth.ts
================
import { useState, useEffect } from 'react';
import { logout as apiLogout } from '../services/api';

interface User {
  name: string;
  email: string;
}

export const useAuth = () => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    // Get user info from token
    const token = localStorage.getItem('token');
    if (token) {
      try {
        const payload = JSON.parse(atob(token.split('.')[1]));
        setUser({
          name: payload.name || payload.email,
          email: payload.email
        });
      } catch (error) {
        console.error('Error parsing token:', error);
      }
    }
  }, []);

  const logout = async () => {
    try {
      await apiLogout();
      localStorage.removeItem('token');
      setUser(null);
    } catch (error) {
      console.error('Error logging out:', error);
    }
  };

  return { user, logout };
};

================
File: frontend/src/services/api.ts
================
// frontend/src/api.ts
import axios, { AxiosInstance } from 'axios';
import { Message, Model, UsageData } from '../types';

// Create an Axios instance with the base URL of your Symfony backend
const api: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:8000/api',
  headers: {
    'Content-Type': 'application/json',
  },
  // Remove withCredentials as we're using JWT tokens, not cookies
});

// Add an interceptor to include the authentication token in every request
api.interceptors.request.use(async (config) => {
  // Check if token needs refresh before making the request
  // Skip token refresh check for the token refresh endpoint to avoid infinite loops
  if (!config.url?.includes('/token/refresh')) {
    await checkTokenRefresh();
  }
  
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Handle errors globally
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    // Don't retry if the error is from the token refresh endpoint itself
    if (error.config.url?.includes('/token/refresh')) {
      localStorage.removeItem('token');
      if (!window.location.pathname.includes('/login') && 
          !window.location.pathname.includes('/callback')) {
        window.location.href = '/login';
      }
      return Promise.reject(error);
    }
    
    // For 401 errors, try to refresh the token and retry the request
    if (error.response?.status === 401) {
      console.log('Attempting to refresh token due to 401 error');
      
      try {
        // Try to refresh the token
        const refreshed = await refreshToken();
        
        if (refreshed) {
          // If token refresh was successful, retry the original request
          const token = localStorage.getItem('token');
          error.config.headers.Authorization = `Bearer ${token}`;
          return axios(error.config);
        } else {
          // If token refresh failed, redirect to login
          if (!window.location.pathname.includes('/login') && 
              !window.location.pathname.includes('/callback')) {
            localStorage.removeItem('token');
            window.location.href = '/login';
          }
        }
      } catch (refreshError) {
        console.error('Error during token refresh:', refreshError);
        // If there was an error refreshing the token, redirect to login
        if (!window.location.pathname.includes('/login') && 
            !window.location.pathname.includes('/callback')) {
          localStorage.removeItem('token');
          window.location.href = '/login';
        }
      }
    }
    
    return Promise.reject(error);
  }
);

// Function to decode JWT token without verification
const decodeToken = (token: string): any => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch (error) {
    console.error('Error decoding token:', error);
    return null;
  }
};

// Add a function to check if token exists and is valid
export const isAuthenticated = (): boolean => {
  const token = localStorage.getItem('token');
  if (!token) return false;
  
  // Decode the token and check if it's expired
  const decodedToken = decodeToken(token);
  if (!decodedToken) return false;
  
  // Check if token has exp claim and is not expired
  if (decodedToken.exp && decodedToken.exp < Date.now() / 1000) {
    // Token is expired
    localStorage.removeItem('token');
    return false;
  }
  
  return true;
};

// Function to refresh the token
export const refreshToken = async (): Promise<boolean> => {
  try {
    // Get the current token (even if expired) to send with the refresh request
    const currentToken = localStorage.getItem('token');
    if (!currentToken) {
      return false;
    }
    
    // Create a new axios instance to avoid interceptors that might cause infinite loops
    const refreshApi = axios.create({
      baseURL: import.meta.env.VITE_API_URL || 'http://localhost:8000/api',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${currentToken}`
      }
    });
    
    const response = await refreshApi.post('/token/refresh');
    const { token } = response.data;
    
    if (token) {
      localStorage.setItem('token', token);
      return true;
    }
    return false;
  } catch (error) {
    console.error('Error refreshing token:', error);
    return false;
  }
};

// Function to check if token needs refresh (e.g., if it expires in less than 1 hour)
export const checkTokenRefresh = async (): Promise<void> => {
  const token = localStorage.getItem('token');
  if (!token) return;
  
  const decodedToken = decodeToken(token);
  if (!decodedToken || !decodedToken.exp) return;
  
  // If token expires in less than 1 hour (3600 seconds), refresh it
  const expiresIn = decodedToken.exp - (Date.now() / 1000);
  if (expiresIn < 3600) {
    await refreshToken();
  }
};

// Fetch available models
export const getModels = async (): Promise<Model[]> => {
  try {
    const response = await api.get('/models');
    // Return the data directly if it's already an array of models
    if (Array.isArray(response.data)) {
      return response.data;
    }
    // Otherwise, return an empty array
    return [];
  } catch (error) {
    console.error('Error fetching models:', error);
    throw error;
  }
};

// Refresh models cache
export const refreshModels = async (): Promise<Model[]> => {
  try {
    const response = await api.get('/models/refresh');
    if (Array.isArray(response.data)) {
      return response.data;
    }
    return [];
  } catch (error) {
    console.error('Error refreshing models:', error);
    throw error;
  }
};

// Send a message to the selected models and get responses
export const sendMessageToModels = async (
  prompt: string,
  modelIds: string[],
  threadId?: string,
  parentId?: string,
  onStream?: (modelId: string, content: string, promptId: string, threadId: string) => void
): Promise<any> => {
  try {
    // Generate a unique promptId for this prompt
    const promptId = `prompt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // If no threadId provided, create a new thread first
    let currentThreadId = threadId;
    if (!currentThreadId) {
      const { threadId: newThreadId } = await createThread();
      currentThreadId = newThreadId;
    }

    if (onStream) {
      // For streaming, we'll handle all selected models
      const responses = await Promise.allSettled(
        modelIds.map(async (modelId) => {
          try {
            const response = await fetch(`${api.defaults.baseURL}/chat`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
                'Accept': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
              },
              credentials: 'include',
              body: JSON.stringify({
                prompt,
                models: [modelId],
                threadId: currentThreadId,
                parentId,
                promptId,
                stream: true
              })
            });

            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.detail || 'Network response was not ok');
            }

            const reader = response.body?.getReader();
            if (!reader) {
              throw new Error('No reader available');
            }

            const decoder = new TextDecoder();
            let content = '';
            let openRouterId = null;
            let buffer = '';

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value);
              buffer += chunk;

              // Process complete lines
              const lines = buffer.split('\n');
              // Keep the last (potentially incomplete) line in the buffer
              buffer = lines.pop() || '';

              for (const line of lines) {
                if (line.trim() === '') continue;
                
                if (line.startsWith('data: ')) {
                  const data = line.slice(6);
                  if (data === '[DONE]') {
                    break;
                  }
                  try {
                    // Skip empty or malformed data
                    if (!data.trim()) continue;
                    
                    const parsed = JSON.parse(data);
                    if (parsed.done) {
                      // Update content with the final response
                      if (parsed.content) {
                        content = parsed.content;
                        onStream(modelId, content, promptId, currentThreadId);
                      }
                    }
                    if (parsed.id) {
                      openRouterId = parsed.id;
                    }
                    if (parsed.content) {
                      content += parsed.content;
                      onStream(modelId, content, promptId, currentThreadId);
                    }
                  } catch (e) {
                    console.error('Error parsing streaming response:', e);
                    // Skip malformed data and continue
                    continue;
                  }
                }
              }
            }

            // Process any remaining data in the buffer
            if (buffer.trim()) {
              const line = buffer.trim();
              if (line.startsWith('data: ')) {
                const data = line.slice(6);
                if (data !== '[DONE]' && data.trim()) {
                  try {
                    const parsed = JSON.parse(data);
                    if (parsed.done) {
                      if (parsed.content) {
                        content = parsed.content;
                        onStream(modelId, content, promptId, currentThreadId);
                      }
                    }
                    if (parsed.id) {
                      openRouterId = parsed.id;
                    }
                    if (parsed.content) {
                      content += parsed.content;
                      onStream(modelId, content, promptId, currentThreadId);
                    }
                  } catch (e) {
                    console.error('Error parsing final streaming response:', e);
                  }
                }
              }
            }

            return {
              modelId,
              content,
              usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 },
              id: openRouterId,
              threadId: currentThreadId
            };
          } catch (error: any) {
            return {
              modelId,
              content: `Error: ${error.message}`,
              usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 },
              id: null,
              threadId: currentThreadId
            };
          }
        })
      );

      // Process all responses, including errors
      const combinedResponses = responses.reduce((acc: { responses: Record<string, { content: string; usage: { prompt_tokens: number; completion_tokens: number; total_tokens: number }; id: string | null }>; threadId: string }, result) => {
        if (result.status === 'fulfilled') {
          const response = result.value;
          acc.responses[response.modelId] = {
            content: response.content,
            usage: response.usage,
            id: response.id
          };
          acc.threadId = currentThreadId;
        }
        return acc;
      }, { responses: {}, threadId: currentThreadId });

      // Ensure we have all responses
      if (Object.keys(combinedResponses.responses).length !== modelIds.length) {
        console.warn('Some model responses were not received:', {
          expected: modelIds.length,
          received: Object.keys(combinedResponses.responses).length,
          models: modelIds,
          responses: Object.keys(combinedResponses.responses)
        });
      }

      return combinedResponses;
    } else {
      // Non-streaming response
      const response = await api.post('/chat', {
        prompt,
        models: modelIds,
        threadId: currentThreadId,
        parentId,
        stream: false
      });
      return response.data;
    }
  } catch (error) {
    console.error('Error sending message:', error);
    throw error;
  }
};

// Fetch chat history
export const getChatHistory = async (): Promise<any[]> => {
  try {
    const response = await api.get('/chat/history');
    return response.data;
  } catch (error) {
    console.error('Error fetching chat history:', error);
    throw error;
  }
};

export const getThreadHistory = async (threadId: string): Promise<any> => {
  try {
    const response = await api.get(`/chat/thread/${threadId}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching thread history:', error);
    throw error;
  }
};

// Function to handle user logout
export const logout = () => {
  localStorage.removeItem('token');
  window.location.href = '/login';
};

export const createThread = async (): Promise<{ threadId: string }> => {
  try {
    const response = await api.post('/chat/thread');
    return response.data;
  } catch (error) {
    console.error('Error creating thread:', error);
    throw error;
  }
};

export interface ThreadCost {
  threadId: string;
  title: string;
  messageCount: number;
  lastMessageDate: string;
  totalCost: number;
  totalTokens: number;
}

export const getThreadCosts = async (): Promise<ThreadCost[]> => {
  try {
    const response = await api.get<ThreadCost[]>('/chat/costs');
    return response.data;
  } catch (error) {
    console.error('Error fetching thread costs:', error);
    throw error;
  }
};

================
File: frontend/src/App.tsx
================
import { useState, useEffect } from 'react';
import { Message, Model, ChatSession } from './types';
import { getModels, getChatHistory, sendMessageToModels, refreshModels, isAuthenticated, checkTokenRefresh, getThreadHistory, logout, createThread } from './services/api';
import { useNavigate, Routes, Route } from 'react-router-dom';
import ModelSelector from './components/ModelSelector';
import ChatWindow from './components/ChatWindow';
import ChatHistory from './components/ChatHistory';
import { ChevronLeft, ChevronRight, LogOut, User, DollarSign } from 'lucide-react';
import CostsPage from './components/CostsPage';
import { Layout } from './components/Layout';
import { Header } from './components/Header';

function App() {
  const navigate = useNavigate();
  const [models, setModels] = useState<Model[]>([]);
  const [messages, setMessages] = useState<Message[]>([]);
  const [showModelSelector, setShowModelSelector] = useState(true);
  const [showChatHistory, setShowChatHistory] = useState(true);
  const [chatHistory, setChatHistory] = useState<ChatSession[]>([]);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [message, setMessage] = useState('');
  const [selectedModels, setSelectedModels] = useState<string[]>([]);
  const [userEmail, setUserEmail] = useState<string | null>(null);

  const MAX_MODELS = 16;
  const hasMessages = messages.length > 0;

  // Helper function to safely get message content
  const getMessageContent = (message: Message): string => {
    if (!message?.content) return '';
    if (typeof message.content === 'string') return message.content;
    if (typeof message.content === 'object' && message.content !== null) {
      return message.content.content || JSON.stringify(message.content);
    }
    return JSON.stringify(message.content);
  };

  // Check authentication on mount
  useEffect(() => {
    const checkAuth = async () => {
      setIsLoading(true);
      
      // Check if user is authenticated
      if (!isAuthenticated()) {
        // Redirect to login if not authenticated
        navigate('/login');
        return;
      }
      
      // Check if token needs to be refreshed
      try {
        await checkTokenRefresh();
        // Get user email from token
        const token = localStorage.getItem('token');
        if (token) {
          const payload = JSON.parse(atob(token.split('.')[1]));
          setUserEmail(payload.email);
        }
      } catch (error) {
        console.error('Error checking token:', error);
        // If token refresh fails, redirect to login
        navigate('/login');
        return;
      }
      
      setIsLoading(false);
    };
    
    checkAuth();
  }, [navigate]);

  // Fetch models on mount
  useEffect(() => {
    const fetchModels = async () => {
      try {
        // Try to get models from cache first
        let fetchedModels = await getModels();
        
        // If no models returned, refresh the cache
        if (!fetchedModels || fetchedModels.length === 0) {
          fetchedModels = await refreshModels();
        }
        
        setModels(fetchedModels.map(model => ({ ...model, selected: false })));
      } catch (error) {
        console.error('Failed to fetch models:', error);
      }
    };

    fetchModels();
  }, []);

  // Fetch chat history on mount
  useEffect(() => {
    const fetchChatHistory = async () => {
      try {
        const history = await getChatHistory();
        const sessions: ChatSession[] = history.map((entry: any) => ({
          id: entry.id.toString(),
          title: entry.title,
          threadId: entry.threadId,
          messages: entry.messages.map((msg: any) => [
            { role: 'user' as const, content: msg.prompt },
            ...Object.entries(msg.responses).map(([modelId, response]: [string, any]) => ({
              role: 'assistant' as const,
              content: typeof response === 'string' ? response : response.content || JSON.stringify(response),
              modelId
            }))
          ]).flat(),
          selectedModels: [],
        }));
        setChatHistory(sessions);
      } catch (error) {
        console.error('Failed to fetch chat history:', error);
      }
    };

    fetchChatHistory();
  }, []);

  const handleModelToggle = (modelId: string) => {
    setModels(prevModels => 
      prevModels.map(model => 
        model.id === modelId ? { ...model, selected: !model.selected } : model
      )
    );
  };

  const handleSendMessage = async (messages: Message[], prompt: string) => {
    setIsLoading(true);
    const selectedModelIds = models.filter(model => model.selected).map(model => model.id);
    
    if (selectedModelIds.length === 0) {
      setIsLoading(false);
      return;
    }

    const reloadThreadData = async (threadId: string) => {
      try {
        const threadData = await getThreadHistory(threadId);
        
        if (threadData && threadData.messages) {
          const updatedMessages: Message[] = [];
          for (const msg of threadData.messages) {
            updatedMessages.push({
              role: 'user',
              content: msg.prompt,
              modelId: msg.modelId
            });
            
            if (msg.responses) {
              Object.entries(msg.responses).forEach(([modelId, content]) => {
                updatedMessages.push({
                  role: 'assistant',
                  content: content as string,
                  modelId: modelId
                });
              });
            }
          }
          setMessages(updatedMessages);
          
          setChatHistory(prev => prev.map(session => 
            session.threadId === threadId
              ? { ...session, messages: updatedMessages }
              : session
          ));
        }
      } catch (error) {
        console.error('Error reloading thread data:', error);
      }
    };

    try {
      // Get promptId from sendMessageToModels
      const promptId = `prompt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Add user message immediately
      const userMessage: Message = {
        role: 'user',
        content: prompt,
        modelId: selectedModelIds[0],
        promptId: promptId,
        threadId: currentSessionId
      };

      setMessages(prev => [...prev, userMessage]);

      // Update chat history with user message
      setChatHistory(prev => {
        // Find existing session with matching threadId
        const existingSession = prev.find(session => session.threadId === currentSessionId);
        
        if (existingSession) {
          // Update existing session
          return prev.map(session => 
            session.threadId === currentSessionId
              ? { ...session, messages: [...session.messages, userMessage] }
              : session
          );
        }
        return prev;
      });

      const response = await sendMessageToModels(
        prompt,
        selectedModelIds,
        currentSessionId || undefined,
        undefined,
        (modelId, content: string | { content: string }, promptId: string, threadId?: string) => {
          const contentString = typeof content === 'string' ? content : content.content || JSON.stringify(content);
          
          // Update currentSessionId if we got a new threadId
          if (threadId) {
            setCurrentSessionId(threadId);
          }

          setMessages(prev => {
            const newMessages = [...prev];
            // Find the message with matching modelId, threadId and promptId
            const existingMessageIndex = newMessages.findIndex(msg => 
              msg.role === 'assistant' && 
              msg.modelId === modelId &&
              msg.threadId === (threadId || currentSessionId) &&
              msg.promptId === promptId
            );

            if (existingMessageIndex !== -1) {
              newMessages[existingMessageIndex] = {
                ...newMessages[existingMessageIndex],
                content: contentString,
                threadId: threadId || currentSessionId
              };
            } else {
              newMessages.push({
                role: 'assistant' as const,
                content: contentString,
                modelId: modelId,
                threadId: threadId || currentSessionId,
                promptId: promptId
              });
            }
            return newMessages;
          });

          // Update chat history with streaming content
          setChatHistory(prev => {
            // Find existing session with matching threadId
            const existingSession = prev.find(session => session.threadId === (threadId || currentSessionId));
            
            if (existingSession) {
              return prev.map(session => {
                if (session.threadId === (threadId || currentSessionId)) {
                  const existingMessageIndex = session.messages.findIndex(msg => 
                    msg.role === 'assistant' && 
                    msg.modelId === modelId &&
                    msg.threadId === (threadId || currentSessionId) &&
                    msg.promptId === promptId
                  );

                  if (existingMessageIndex !== -1) {
                    const updatedMessages = [...session.messages];
                    updatedMessages[existingMessageIndex] = {
                      ...updatedMessages[existingMessageIndex],
                      content: contentString,
                      threadId: threadId || currentSessionId
                    };
                    return { ...session, messages: updatedMessages };
                  } else {
                    return {
                      ...session,
                      messages: [...session.messages, {
                        role: 'assistant',
                        content: contentString,
                        modelId: modelId,
                        threadId: threadId || currentSessionId,
                        promptId: promptId
                      }]
                    };
                  }
                }
                return session;
              });
            }
            return prev;
          });
        }
      );

      // Update currentSessionId if we got a new threadId from the response
      if (response.threadId) {
        setCurrentSessionId(response.threadId);
        // Update chat history with new threadId
        setChatHistory(prev => prev.map(session => 
          session.threadId === currentSessionId || (!session.threadId && session.id === Date.now().toString())
            ? { ...session, threadId: response.threadId }
            : session
        ));
        // Update all messages with new threadId
        setMessages(prev => prev.map(msg => ({
          ...msg,
          threadId: response.threadId
        })));
      }

      // Only reload thread data if we don't have streaming responses
      const hasStreamingResponses = messages.some(msg => 
        msg.role === 'assistant' && 
        msg.threadId === currentSessionId && 
        msg.promptId === promptId
      );
      
      if (!hasStreamingResponses && currentSessionId) {
        setTimeout(async () => {
          await reloadThreadData(currentSessionId);
        }, 500);
      }
    } catch (error: any) {
      console.error('Error sending message:', error);
      let errorMessage = 'Error: Failed to send message. Please try again.';
      
      if (error.response?.status === 500 && error.response?.data?.detail?.includes('Maximum execution time')) {
        errorMessage = 'The request took too long to process. Please try again or try with a shorter message.';
      } else if (error.response?.data?.detail) {
        errorMessage = `Error: ${error.response.data.detail}`;
      }

      const errorResponse: Message = {
        role: 'assistant' as const,
        content: errorMessage,
        modelId: selectedModelIds[0]
      };
      
      setMessages(prev => [...prev, errorResponse]);
      
      // Update chat history with error message
      setChatHistory(prev => prev.map(session => 
        (session.threadId === currentSessionId || (!session.threadId && session.id === Date.now().toString()))
          ? { ...session, messages: [...session.messages, errorResponse] }
          : session
      ));

      // If we have a thread ID, try to reload it after error
      if (currentSessionId) {
        setTimeout(async () => {
          try {
            await reloadThreadData(currentSessionId);
          } catch (reloadError) {
            console.error('Error reloading thread after error:', reloadError);
          }
        }, 1000);
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleSelectChat = async (sessionId: string) => {
    const session = chatHistory.find(s => s.id === sessionId);
    if (session) {
      setCurrentSessionId(session.threadId || sessionId);
      setMessages(session.messages);
      
      // Update model selection based on the chat
      const modelIds = [...new Set(session.messages
        .filter((m: Message) => m.role === 'assistant')
        .map((m: Message) => m.modelId))];
        
      setModels(prevModels => 
        prevModels.map(model => ({
          ...model,
          selected: modelIds.includes(model.id)
        }))
      );
    }
  };

  const handleStartNewChat = async () => {
    try {
      // Create a new thread immediately
      const { threadId } = await createThread();
      setCurrentSessionId(threadId);
      setMessages([]);
      setModels(prevModels => prevModels.map(model => ({ ...model, selected: false })));
      
      // Add the new thread to chat history
      setChatHistory(prev => [{
        id: Date.now().toString(),
        title: 'New Chat',
        threadId: threadId,
        messages: [],
        selectedModels: []
      }, ...prev]);
    } catch (error) {
      console.error('Error creating new chat:', error);
    }
  };

  const toggleChatHistory = () => {
    setShowChatHistory(!showChatHistory);
  };

  return (
    <div className="flex h-screen bg-gray-100">
      {/* Header */}
      <div className="fixed top-0 left-0 right-0 bg-white border-b z-10">
        <Header />
      </div>

      {/* Main Content */}
      <div className="flex w-full pt-16">
        <Routes>
          <Route path="/costs" element={<CostsPage />} />
          <Route path="/" element={
            <>
              {/* Chat History Sidebar */}
              <div className={`w-64 bg-white border-r ${showChatHistory ? '' : 'hidden'}`}>
                <div className="p-4 border-b">
                  <h2 className="text-lg font-semibold">Chat History</h2>
                </div>
                <div className="overflow-y-auto h-full">
                  {chatHistory.map((session) => (
                    <div
                      key={session.threadId || session.id}
                      className={`p-4 cursor-pointer hover:bg-gray-50 ${
                        currentSessionId === (session.threadId || session.id) ? 'bg-gray-50' : ''
                      }`}
                      onClick={() => handleSelectChat(session.id)}
                    >
                      <h3 className="font-medium truncate">{session.title || 'New Chat'}</h3>
                      <p className="text-sm text-gray-500 truncate">
                        {session.messages[session.messages.length - 1] 
                          ? getMessageContent(session.messages[session.messages.length - 1])
                          : 'No messages'}
                      </p>
                    </div>
                  ))}
                </div>
              </div>

              {/* Main Chat Area */}
              <div className="flex-1 flex flex-col">
                {/* Model Selector */}
                <div className="bg-white border-b p-3">
                  <ModelSelector
                    models={models}
                    onModelToggle={handleModelToggle}
                    maxModels={MAX_MODELS}
                  />
                </div>

                {/* Chat Window */}
                <ChatWindow
                  messages={messages}
                  models={models}
                  onModelToggle={handleModelToggle}
                  onSendMessage={handleSendMessage}
                  isLoading={isLoading}
                />
              </div>
            </>
          } />
        </Routes>
      </div>
    </div>
  );
}

export default App;

================
File: frontend/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Light mode styles */
@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
}

/* Dark mode styles */
@media (prefers-color-scheme: dark) {
  :root {
    color: rgba(255, 255, 255, 0.87);
    background-color: #242424;
  }
  
  /* Ensure text in white containers remains dark */
  .bg-white {
    color: #213547;
  }
  
  .bg-gray-50 {
    color: #213547;
  }
}

/* Custom scrollbar for horizontal scrolling */
.overflow-x-auto::-webkit-scrollbar {
  height: 8px;
}

.overflow-x-auto::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.overflow-x-auto::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 4px;
}

.overflow-x-auto::-webkit-scrollbar-thumb:hover {
  background: #a1a1a1;
}

/* For Firefox */
.overflow-x-auto {
  scrollbar-width: thin;
  scrollbar-color: #c1c1c1 #f1f1f1;
}

/* Ensure the scrollbar is visible on hover */
.overflow-x-auto:hover::-webkit-scrollbar-thumb {
  background: #a1a1a1;
}

================
File: frontend/src/index.tsx
================
// frontend/src/index.tsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import App from './App';
import Login from './components/Login';
import Callback from './components/Callback';
import CostsPage from './components/CostsPage';
import './index.css';

// Protected Route Component
const ProtectedRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const token = localStorage.getItem('token');
    return token ? <>{children}</> : <Navigate to="/login" />;
};

createRoot(document.getElementById('root')!).render(
    <StrictMode>
        <Router>
            <Routes>
                <Route path="/login" element={<Login />} />
                <Route path="/callback" element={<Callback />} />
                <Route
                    path="/"
                    element={
                        <ProtectedRoute>
                            <App />
                        </ProtectedRoute>
                    }
                />
                <Route
                    path="/costs"
                    element={
                        <ProtectedRoute>
                            <CostsPage />
                        </ProtectedRoute>
                    }
                />
            </Routes>
        </Router>
    </StrictMode>
);

================
File: frontend/src/types.ts
================
export interface Message {
  role: 'user' | 'assistant';
  content: string | { content: string } | any;
  modelId?: string;
  id?: string;
  threadId?: string | null;
  promptId?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export interface Model {
  id: string;
  name: string;
  description?: string;
  provider?: string;
  selected?: boolean;
  pricing?: {
    prompt: number;
    completion: number;
    unit: string;
  };
}

export interface ChatSession {
  id: string;
  title: string;
  messages: Message[];
  selectedModels: string[];
  threadId?: string | null;
  parentId?: string;
}

export interface UsageData {
  promptTokens?: number;
  completionTokens?: number;
  totalTokens?: number;
}

================
File: frontend/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: frontend/.dockerignore
================
# Git
.git
.gitignore

# Docker
Dockerfile
docker-compose.yml
docker-compose.*.yml

# Node.js
node_modules
npm-debug.log
yarn-error.log
yarn-debug.log

# Build files
/dist
/build

# IDE files
/.idea/
/.vscode/

# OS specific files
.DS_Store
Thumbs.db

================
File: frontend/.gitignore
================
# Node modules
node_modules/

# Build output
dist/

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.*.local

# Editor directories and files
.idea/
.vscode/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# MacOS files
.DS_Store

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

================
File: frontend/Dockerfile
================
FROM node:20-alpine

# Set working directory
WORKDIR /app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy application files
COPY . .

# Expose port 3000
EXPOSE 3000

# Start development server
CMD ["npm", "run", "dev", "--", "--host", "0.0.0.0"]

================
File: frontend/Dockerfile.prod
================
# Build stage
FROM node:20-alpine AS build

# Set working directory
WORKDIR /app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy application files
COPY . .

# Build the application
ARG VITE_API_URL
ENV VITE_API_URL=${VITE_API_URL}
RUN npm run build

# Production stage
FROM nginx:alpine

# Copy built assets from build stage
COPY --from=build /app/dist /usr/share/nginx/html

# Copy nginx configuration
COPY --from=build /app/nginx.conf /etc/nginx/conf.d/default.conf

# Expose port 80
EXPOSE 80

# Start Nginx
CMD ["nginx", "-g", "daemon off;"]

================
File: frontend/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: frontend/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>

================
File: frontend/nginx.conf
================
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    gzip_comp_level 6;
    gzip_min_length 1000;

    # Cache static assets
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg)$ {
        expires 30d;
        add_header Cache-Control "public, no-transform";
    }

    # Handle SPA routing
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Security headers
    add_header X-Content-Type-Options "nosniff";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Frame-Options "SAMEORIGIN";
    add_header Referrer-Policy "strict-origin-when-cross-origin";
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self' localhost:*;";

    # Error pages
    error_page 404 /index.html;
    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        root /usr/share/nginx/html;
    }
}

================
File: frontend/package.json
================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@types/react-router-dom": "^5.3.3",
    "axios": "^1.8.4",
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^7.4.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.2"
  }
}

================
File: frontend/postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: frontend/README.md
================
# Multi-Model Chat Comparison App

A web application that allows users to compare outputs from multiple AI models side-by-side using a single prompt.

## Features

- **Multi-Model Selection**: Select up to 16 different AI models to compare simultaneously
- **Side-by-Side Comparison**: View model responses in a horizontal scrollable container
- **Chat History**: Access previous conversations through a collapsible sidebar
- **Model Filtering**: Search for specific models by name or description
- **Dynamic UI**: Responsive interface that adapts based on the conversation state
- **Model Management**: Add or remove models during an active conversation

## Implementation Details

### UI Components

1. **ModelSelector**
   - Displays available models in a single-row, horizontally scrollable list
   - Includes search functionality to filter models
   - Shows selection count (e.g., "5/16 selected")
   - Disables selection when maximum limit is reached
   - Provides informational messages based on selection state

2. **ChatWindow**
   - Displays conversation history with user messages and model responses
   - Groups responses by user message
   - Shows model responses in a horizontally scrollable container
   - Includes a model selection bar for quick toggling during conversation

3. **ChatInput**
   - Provides a text input for user messages
   - Disables sending when no models are selected
   - Supports sending messages with Enter key

4. **ChatHistory**
   - Shows a list of previous conversations
   - Includes a "Start new chat" button
   - Provides tabs for "Chats" and "Projects"
   - Can be collapsed to provide more space for the main chat area

5. **ModelCheckbox**
   - Compact representation of selected models
   - Allows quick toggling of models during conversation

### Key Features Implemented

- **Collapsible Sidebars**: Both the model selector and chat history can be hidden to maximize chat space
- **Dynamic Layout**: Chat window expands after the first message is sent
- **Responsive Design**: UI adapts to different screen sizes and states
- **Visual Feedback**: Clear indicators for selected models and disabled states
- **Informational Messages**: Contextual help messages based on the current state

### Technical Implementation

- **React + TypeScript**: Type-safe component architecture
- **Tailwind CSS**: Utility-first styling approach
- **Lucide React**: Modern icon library
- **Component-Based Architecture**: Modular design with reusable components
- **State Management**: React useState hooks for managing application state
- **Mock Data**: Simulated responses for development and testing

## Future Enhancements

- **OpenRouter API Integration**: Connect to real AI models via OpenRouter
- **Persistent Storage**: Save chat history and preferences
- **Authentication**: User accounts and personalized experiences
- **Export Functionality**: Save or share comparison results
- **Advanced Filtering**: Filter models by capabilities, size, or performance
- **Customizable Layout**: User-defined UI preferences
- **Markdown Support**: Rich text formatting in messages and responses

## Development Journey

The application was developed iteratively with the following key milestones:

1. **Initial Setup**: Created basic component structure and UI layout
2. **Model Selection**: Implemented model selection with a limit of 4 models
3. **Chat Interface**: Added chat input and message display
4. **Response Comparison**: Implemented side-by-side model response display
5. **UI Enhancements**: Improved visual design and user experience
6. **Chat History**: Added collapsible sidebar for chat history
7. **Increased Capacity**: Expanded model selection limit from 4 to 10, then to 16
8. **Responsive Design**: Ensured proper behavior across different states and screen sizes

## Technical Decisions

- **Single Row Model Selection**: Optimized for horizontal scrolling to save vertical space
- **Collapsible UI Elements**: Maximized available space for the chat interface
- **Delayed Response Simulation**: Added realistic timing for model responses
- **Component Modularity**: Designed components for reusability and maintainability
- **Visual Feedback**: Implemented clear state indicators throughout the UI

================
File: frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: frontend/tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

================
File: frontend/tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: frontend/tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: frontend/vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  optimizeDeps: {
    exclude: ['lucide-react'],
  },
  server: {
    port: 5173,
    cors: true,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      }
    }
  },
})

================
File: .env.prod.example
================
# Docker Compose production environment variables
COMPOSE_PROJECT_NAME=ai-multichat

# Application settings
APP_SECRET=change_this_to_a_secure_random_string
CORS_ALLOW_ORIGIN=^https?://your-domain\.com$
FRONTEND_URL=https://your-domain.com
BACKEND_URL=https://api.your-domain.com

# MySQL configuration
MYSQL_DATABASE=app
MYSQL_USER=app
MYSQL_PASSWORD=change_this_to_a_secure_password
MYSQL_ROOT_PASSWORD=change_this_to_a_secure_root_password

# Port configuration
FRONTEND_PORT=80
BACKEND_PORT=80

# OpenRouter API configuration
OPENROUTER_API_KEY=your_openrouter_api_key
OPENROUTER_CACHE_TTL=3600

================
File: .gitignore
================
# Docker environment files
.env
.env.local
.env.prod

# Logs
logs/
*.log

# Editor directories and files
.idea/
.vscode/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.DS_Store

# Temporary files
*.tmp
*.bak
*.swp
*~.nib

================
File: docker-compose.prod.yml
================
version: '3.8'

services:
  # Backend services
  php:
    build:
      context: ./backend
      dockerfile: Dockerfile.prod
    restart: unless-stopped
    volumes:
      - ./backend/config/jwt:/var/www/html/config/jwt
    depends_on:
      - database
    environment:
      - APP_ENV=prod
      - APP_SECRET=${APP_SECRET}
      - DATABASE_URL=mysql://${MYSQL_USER}:${MYSQL_PASSWORD}@database:3306/${MYSQL_DATABASE}?serverVersion=8.0.32&charset=utf8mb4
      - CORS_ALLOW_ORIGIN=${CORS_ALLOW_ORIGIN}
      - FRONTEND_URL=${FRONTEND_URL}
      - OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
      - OPENROUTER_CACHE_TTL=${OPENROUTER_CACHE_TTL:-3600}

  nginx_backend:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "${BACKEND_PORT:-8000}:80"
    volumes:
      - ./backend/public:/var/www/html/public:ro
      - ./docker/nginx/backend.conf:/etc/nginx/conf.d/default.conf:ro
    depends_on:
      - php

  database:
    image: mysql:8.0
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
    volumes:
      - database_data:/var/lib/mysql:rw
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${MYSQL_ROOT_PASSWORD}"]
      timeout: 5s
      retries: 5
      start_period: 60s

  # Frontend services
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.prod
      args:
        - VITE_API_URL=${BACKEND_URL}/api
    restart: unless-stopped
    ports:
      - "${FRONTEND_PORT:-3000}:80"
    depends_on:
      - nginx_backend

volumes:
  database_data:

================
File: docker-compose.yml
================
version: '3.8'

services:
  # Backend services
  php:
    build:
      context: ./backend
      dockerfile: Dockerfile
    volumes:
      - ./backend:/var/www/html
      - ./backend/var:/var/www/html/var
    depends_on:
      - database
    environment:
      - APP_ENV=dev
      - DATABASE_URL=mysql://app:!ChangeMe!@database:3306/app?serverVersion=8.0.32&charset=utf8mb4
      - CORS_ALLOW_ORIGIN=^https?://(localhost|127\.0\.0\.1)(:[0-9]+)?$
      - FRONTEND_URL=http://localhost:3000

  nginx_backend:
    image: nginx:alpine
    ports:
      - "8000:80"
    volumes:
      - ./backend:/var/www/html
      - ./docker/nginx/backend.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - php

  database:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: ${MYSQL_DATABASE:-app}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-!ChangeMe!}
      MYSQL_USER: ${MYSQL_USER:-app}
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-!ChangeMe!}
    ports:
      - "3306:3306"
    volumes:
      - database_data:/var/lib/mysql:rw
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${MYSQL_ROOT_PASSWORD:-!ChangeMe!}"]
      timeout: 5s
      retries: 5
      start_period: 60s

  # Frontend services
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    volumes:
      - ./frontend:/app
      - /app/node_modules
    ports:
      - "3000:3000"
    environment:
      - VITE_API_URL=http://localhost:8000/api
    depends_on:
      - nginx_backend
    command: npm run dev -- --host 0.0.0.0 --port 3000

volumes:
  database_data:

================
File: docker-deploy.sh
================
#!/bin/bash
set -e

# Check if .env.prod exists
if [ ! -f .env.prod ]; then
    echo "Error: .env.prod file not found."
    echo "Please create it by copying .env.prod.example and updating the values:"
    echo "cp .env.prod.example .env.prod"
    exit 1
fi

# Validate required environment variables
echo "Validating environment variables..."
source .env.prod
if [ -z "$BACKEND_URL" ] || [ -z "$FRONTEND_URL" ]; then
    echo "Error: BACKEND_URL and FRONTEND_URL must be set in .env.prod"
    exit 1
fi

echo "Deploying AI MultiChat application to production..."

# Build and start the containers
echo "Building and starting containers..."
docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d --build

# Wait for database to be ready
echo "Waiting for database to be ready..."
sleep 15

# Run database migrations
echo "Running database migrations..."
docker-compose -f docker-compose.prod.yml --env-file .env.prod exec -T php bin/console doctrine:migrations:migrate --no-interaction

# Check for JWT keys
echo "Checking for JWT keys..."
if ! docker-compose -f docker-compose.prod.yml --env-file .env.prod exec -T php test -f config/jwt/private.pem; then
    echo "Generating JWT keys..."
    docker-compose -f docker-compose.prod.yml --env-file .env.prod exec -T php bin/console lexik:jwt:generate-keypair --no-interaction
fi

# Cache models
echo "Caching models..."
docker-compose -f docker-compose.prod.yml --env-file .env.prod exec -T php bin/console app:cache:models

# Clear cache
echo "Clearing cache..."
docker-compose -f docker-compose.prod.yml --env-file .env.prod exec -T php bin/console cache:clear --env=prod

echo ""
echo "Deployment complete!"
echo "Your application should now be running at the configured domains."
echo ""
echo "To view logs, run: docker-compose -f docker-compose.prod.yml --env-file .env.prod logs -f"

================
File: docker-init.sh
================
#!/bin/bash
set -e

echo "Initializing AI MultiChat application..."

# Check if .env file exists, if not create it from example
if [ ! -f .env ]; then
    echo "Creating .env file from example..."
    cp .env.prod.example .env
    # Replace example values with localhost values for development
    sed -i '' 's/your-domain\.com/localhost/g' .env
    sed -i '' 's/api\.your-domain\.com/localhost:8000/g' .env
    sed -i '' 's/^FRONTEND_PORT=.*/FRONTEND_PORT=3000/' .env
    sed -i '' 's/^BACKEND_PORT=.*/BACKEND_PORT=8000/' .env
fi

# Start Docker containers
echo "Starting Docker containers..."
docker-compose up -d

# Wait for database to be ready
echo "Waiting for database to be ready..."
sleep 10

# Install backend dependencies
echo "Installing backend dependencies..."
docker-compose exec -T php composer install

# Run database migrations
echo "Running database migrations..."
docker-compose exec -T php bin/console doctrine:migrations:migrate --no-interaction

# Generate JWT keys if they don't exist
echo "Checking for JWT keys..."
if [ ! -f backend/config/jwt/private.pem ]; then
    echo "Generating JWT keys..."
    docker-compose exec -T php bin/console lexik:jwt:generate-keypair --no-interaction
fi

# Cache models
echo "Caching models..."
docker-compose exec -T php bin/console app:cache:models

echo ""
echo "Initialization complete! You can access the application at:"
echo "- Frontend: http://localhost:3000"
echo "- Backend API: http://localhost:8000/api"
echo ""
echo "To view logs, run: docker-compose logs -f"

================
File: README.md
================
# AI MultiChat Application

A multi-model chat application with Symfony 7 backend and React frontend.

## Docker Setup

This project uses Docker for local development. The setup includes:

- PHP 8.2 (FPM) for the Symfony backend
- Nginx as a web server for the backend
- MySQL 8.0 database
- Node.js for the React frontend

### Prerequisites

- Docker and Docker Compose installed on your system
- Git

### Getting Started

#### Option 1: Using the initialization script

1. Clone the repository:
   ```
   git clone <repository-url>
   cd ai-multichat
   ```

2. Run the initialization script:
   ```
   ./docker-init.sh
   ```
   
   This script will:
   - Start all Docker containers
   - Install backend dependencies
   - Run database migrations
   - Generate JWT keys if needed
   - Cache models

3. Access the application:
   - Frontend: http://localhost:3000
   - Backend API: http://localhost:8000/api

#### Option 2: Manual setup

1. Clone the repository:
   ```
   git clone <repository-url>
   cd ai-multichat
   ```

2. Start the Docker containers:
   ```
   docker-compose up -d
   ```

3. Install backend dependencies:
   ```
   docker-compose exec php composer install
   ```

4. Create the database schema:
   ```
   docker-compose exec php bin/console doctrine:migrations:migrate --no-interaction
   ```

5. Generate JWT keys (if not already present):
   ```
   docker-compose exec php bin/console lexik:jwt:generate-keypair
   ```

6. Cache models:
   ```
   docker-compose exec php bin/console app:cache:models
   ```

7. Access the application:
   - Frontend: http://localhost:3000
   - Backend API: http://localhost:8000/api

### Useful Commands

- View logs:
  ```
  docker-compose logs -f
  ```

- Access the PHP container:
  ```
  docker-compose exec php bash
  ```

- Access the database:
  ```
  docker-compose exec database mysql -u app -p
  ```

- Stop the containers:
  ```
  docker-compose down
  ```

- Rebuild containers after Dockerfile changes:
  ```
  docker-compose up -d --build
  ```

## Environment Variables

The main environment variables are stored in the `.env` file at the root of the project. You can modify these values to suit your needs.

For backend-specific environment variables, check the `backend/.env` file.

## Development

- Backend code is in the `backend/` directory
- Frontend code is in the `frontend/` directory

Changes to the code will be automatically reflected in the running application due to the volume mounts in the Docker Compose configuration.

## Production Deployment

For production deployment, this project includes optimized Docker configurations:

### Setup

#### Option 1: Using the deployment script

1. Copy the example production environment file:
   ```
   cp .env.prod.example .env.prod
   ```

2. Edit `.env.prod` with your production settings:
   - Set secure passwords for the database
   - Configure domain names
   - Set API keys
   - Adjust other settings as needed

3. Run the deployment script:
   ```
   ./docker-deploy.sh
   ```
   
   This script will:
   - Build and start all production containers
   - Run database migrations
   - Generate JWT keys if needed
   - Cache models
   - Clear the Symfony cache

#### Option 2: Manual deployment

1. Copy the example production environment file:
   ```
   cp .env.prod.example .env.prod
   ```

2. Edit `.env.prod` with your production settings:
   - Set secure passwords for the database
   - Configure domain names
   - Set API keys
   - Adjust other settings as needed

3. Build and start the production containers:
   ```
   docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d --build
   ```

4. Run database migrations:
   ```
   docker-compose -f docker-compose.prod.yml --env-file .env.prod exec php bin/console doctrine:migrations:migrate --no-interaction
   ```

5. Generate JWT keys if needed:
   ```
   docker-compose -f docker-compose.prod.yml --env-file .env.prod exec php bin/console lexik:jwt:generate-keypair --no-interaction
   ```

6. Cache models:
   ```
   docker-compose -f docker-compose.prod.yml --env-file .env.prod exec php bin/console app:cache:models
   ```

7. Clear the Symfony cache:
   ```
   docker-compose -f docker-compose.prod.yml --env-file .env.prod exec php bin/console cache:clear --env=prod
   ```

### Production Architecture

The production setup includes:

- Multi-stage builds for optimized container images
- Nginx for serving both frontend and backend
- PHP-FPM with optimized settings for Symfony
- Persistent MySQL database volume
- Environment variable configuration
- Security headers and optimizations

### Maintenance

- View logs:
  ```
  docker-compose -f docker-compose.prod.yml --env-file .env.prod logs -f
  ```

- Restart services:
  ```
  docker-compose -f docker-compose.prod.yml --env-file .env.prod restart
  ```

- Update application:
  ```
  git pull
  docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d --build
  docker-compose -f docker-compose.prod.yml --env-file .env.prod exec php bin/console doctrine:migrations:migrate --no-interaction
  ```



================================================================
End of Codebase
================================================================
